
 /----------------------------------------------------------------------------\
 |                                                                            |
 |  yosys -- Yosys Open SYnthesis Suite                                       |
 |                                                                            |
 |  Copyright (C) 2012 - 2019  Clifford Wolf <clifford@clifford.at>           |
 |                                                                            |
 |  Permission to use, copy, modify, and/or distribute this software for any  |
 |  purpose with or without fee is hereby granted, provided that the above    |
 |  copyright notice and this permission notice appear in all copies.         |
 |                                                                            |
 |  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES  |
 |  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF          |
 |  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR   |
 |  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES    |
 |  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN     |
 |  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF   |
 |  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.            |
 |                                                                            |
 \----------------------------------------------------------------------------/

 Yosys 0.9 (git sha1 1979e0b)


-- Executing script file `run.ys' --

1. Executing Verilog-2005 frontend: new_alu.sv
Parsing SystemVerilog input from `new_alu.sv' to AST representation.
Generating RTLIL representation for module `\addition_1'.
Generating RTLIL representation for module `\division_1'.
Generating RTLIL representation for module `\right_shift_1'.
Generating RTLIL representation for module `\zm_to_u2'.
Generating RTLIL representation for module `\absolute'.
Generating RTLIL representation for module `\comparison_1'.
Generating RTLIL representation for module `\division'.
Generating RTLIL representation for module `\right_shift_2'.
Generating RTLIL representation for module `\add_bit'.
Generating RTLIL representation for module `\comparison_2'.
Generating RTLIL representation for module `\sub_and_mul'.
Generating RTLIL representation for module `\u2_to_zm'.
Generating RTLIL representation for module `\new_alu'.
Successfully finished Verilog frontend.

2. Executing HIERARCHY pass (managing design hierarchy).

2.1. Analyzing design hierarchy..
Top module:  \synth_new_alu
Used module:     \addition_1
Used module:     \division_1
Used module:     \right_shift_1
Used module:     \zm_to_u2
Used module:     \sub_and_mul
Used module:     \comparison_2
Used module:     \add_bit
Used module:     \u2_to_zm
Used module:     \absolute
Used module:     \comparison_1
Used module:     \division
Used module:     \right_shift_2

2.2. Executing AST frontend in derive mode using pre-parsed AST for module `\addition_1'.
Parameter \M = 8
Parameter \K = 8
Generating RTLIL representation for module `$paramod\addition_1\M=8\K=8'.

2.3. Executing AST frontend in derive mode using pre-parsed AST for module `\division_1'.
Parameter \M = 8
Parameter \K = 8
Generating RTLIL representation for module `$paramod\division_1\M=8\K=8'.

2.4. Executing AST frontend in derive mode using pre-parsed AST for module `\right_shift_1'.
Parameter \M = 8
Parameter \K = 8
Generating RTLIL representation for module `$paramod\right_shift_1\M=8\K=8'.

2.5. Executing AST frontend in derive mode using pre-parsed AST for module `\zm_to_u2'.
Parameter \M = 8
Parameter \K = 8
Generating RTLIL representation for module `$paramod\zm_to_u2\M=8\K=8'.

2.6. Executing AST frontend in derive mode using pre-parsed AST for module `\sub_and_mul'.
Parameter \M = 8
Parameter \K = 8
Generating RTLIL representation for module `$paramod\sub_and_mul\M=8\K=8'.

2.7. Executing AST frontend in derive mode using pre-parsed AST for module `\comparison_2'.
Parameter \M = 8
Parameter \K = 8
Generating RTLIL representation for module `$paramod\comparison_2\M=8\K=8'.

2.8. Executing AST frontend in derive mode using pre-parsed AST for module `\add_bit'.
Parameter \M = 8
Parameter \K = 8
Generating RTLIL representation for module `$paramod\add_bit\M=8\K=8'.

2.9. Executing AST frontend in derive mode using pre-parsed AST for module `\u2_to_zm'.
Parameter \M = 8
Parameter \K = 8
Generating RTLIL representation for module `$paramod\u2_to_zm\M=8\K=8'.

2.10. Executing AST frontend in derive mode using pre-parsed AST for module `\absolute'.
Parameter \M = 8
Parameter \K = 8
Generating RTLIL representation for module `$paramod\absolute\M=8\K=8'.

2.11. Executing AST frontend in derive mode using pre-parsed AST for module `\comparison_1'.
Parameter \M = 8
Parameter \K = 8
Generating RTLIL representation for module `$paramod\comparison_1\M=8\K=8'.

2.12. Executing AST frontend in derive mode using pre-parsed AST for module `\division'.
Parameter \M = 8
Parameter \K = 8
Generating RTLIL representation for module `$paramod\division\M=8\K=8'.

2.13. Executing AST frontend in derive mode using pre-parsed AST for module `\right_shift_2'.
Parameter \M = 8
Parameter \K = 8
Generating RTLIL representation for module `$paramod\right_shift_2\M=8\K=8'.

2.14. Analyzing design hierarchy..
Top module:  \synth_new_alu
Used module:     $paramod\addition_1\M=8\K=8
Used module:     $paramod\division_1\M=8\K=8
Used module:     $paramod\right_shift_1\M=8\K=8
Used module:     $paramod\zm_to_u2\M=8\K=8
Used module:     $paramod\sub_and_mul\M=8\K=8
Used module:     $paramod\comparison_2\M=8\K=8
Used module:     $paramod\add_bit\M=8\K=8
Used module:     $paramod\u2_to_zm\M=8\K=8
Used module:     $paramod\absolute\M=8\K=8
Used module:     $paramod\comparison_1\M=8\K=8
Used module:     $paramod\division\M=8\K=8
Used module:     $paramod\right_shift_2\M=8\K=8

2.15. Analyzing design hierarchy..
Top module:  \synth_new_alu
Used module:     $paramod\addition_1\M=8\K=8
Used module:     $paramod\division_1\M=8\K=8
Used module:     $paramod\right_shift_1\M=8\K=8
Used module:     $paramod\zm_to_u2\M=8\K=8
Used module:     $paramod\sub_and_mul\M=8\K=8
Used module:     $paramod\comparison_2\M=8\K=8
Used module:     $paramod\add_bit\M=8\K=8
Used module:     $paramod\u2_to_zm\M=8\K=8
Used module:     $paramod\absolute\M=8\K=8
Used module:     $paramod\comparison_1\M=8\K=8
Used module:     $paramod\division\M=8\K=8
Used module:     $paramod\right_shift_2\M=8\K=8
Removing unused module `\new_alu'.
Removing unused module `\u2_to_zm'.
Removing unused module `\sub_and_mul'.
Removing unused module `\comparison_2'.
Removing unused module `\add_bit'.
Removing unused module `\right_shift_2'.
Removing unused module `\division'.
Removing unused module `\comparison_1'.
Removing unused module `\absolute'.
Removing unused module `\zm_to_u2'.
Removing unused module `\right_shift_1'.
Removing unused module `\division_1'.
Removing unused module `\addition_1'.
Removed 13 unused modules.

3. Executing SYNTH pass.

3.1. Executing HIERARCHY pass (managing design hierarchy).

3.1.1. Analyzing design hierarchy..
Top module:  \synth_new_alu
Used module:     $paramod\addition_1\M=8\K=8
Used module:     $paramod\division_1\M=8\K=8
Used module:     $paramod\right_shift_1\M=8\K=8
Used module:     $paramod\zm_to_u2\M=8\K=8
Used module:     $paramod\sub_and_mul\M=8\K=8
Used module:     $paramod\comparison_2\M=8\K=8
Used module:     $paramod\add_bit\M=8\K=8
Used module:     $paramod\u2_to_zm\M=8\K=8
Used module:     $paramod\absolute\M=8\K=8
Used module:     $paramod\comparison_1\M=8\K=8
Used module:     $paramod\division\M=8\K=8
Used module:     $paramod\right_shift_2\M=8\K=8

3.1.2. Analyzing design hierarchy..
Top module:  \synth_new_alu
Used module:     $paramod\addition_1\M=8\K=8
Used module:     $paramod\division_1\M=8\K=8
Used module:     $paramod\right_shift_1\M=8\K=8
Used module:     $paramod\zm_to_u2\M=8\K=8
Used module:     $paramod\sub_and_mul\M=8\K=8
Used module:     $paramod\comparison_2\M=8\K=8
Used module:     $paramod\add_bit\M=8\K=8
Used module:     $paramod\u2_to_zm\M=8\K=8
Used module:     $paramod\absolute\M=8\K=8
Used module:     $paramod\comparison_1\M=8\K=8
Used module:     $paramod\division\M=8\K=8
Used module:     $paramod\right_shift_2\M=8\K=8
Removed 0 unused modules.

3.2. Executing PROC pass (convert processes to netlists).

3.2.1. Executing PROC_CLEAN pass (remove empty switches from decision trees).
Cleaned up 0 empty switches.

3.2.2. Executing PROC_RMDEAD pass (remove dead branches from decision trees).
Marked 12 switch rules as full_case in process $proc$new_alu.sv:305$378 in module $paramod\right_shift_2\M=8\K=8.
Marked 12 switch rules as full_case in process $proc$new_alu.sv:253$345 in module $paramod\division\M=8\K=8.
Marked 2 switch rules as full_case in process $proc$new_alu.sv:223$317 in module $paramod\comparison_1\M=8\K=8.
Marked 12 switch rules as full_case in process $proc$new_alu.sv:172$290 in module $paramod\absolute\M=8\K=8.
Marked 2 switch rules as full_case in process $proc$new_alu.sv:537$275 in module $paramod\u2_to_zm\M=8\K=8.
Marked 2 switch rules as full_case in process $proc$new_alu.sv:361$266 in module $paramod\add_bit\M=8\K=8.
Marked 6 switch rules as full_case in process $proc$new_alu.sv:411$249 in module $paramod\comparison_2\M=8\K=8.
Marked 2 switch rules as full_case in process $proc$new_alu.sv:488$242 in module $paramod\sub_and_mul\M=8\K=8.
Marked 1 switch rules as full_case in process $proc$new_alu.sv:142$238 in module $paramod\zm_to_u2\M=8\K=8.
Marked 1 switch rules as full_case in process $proc$new_alu.sv:111$234 in module $paramod\right_shift_1\M=8\K=8.
Marked 1 switch rules as full_case in process $proc$new_alu.sv:82$230 in module $paramod\division_1\M=8\K=8.
Marked 8 switch rules as full_case in process $proc$new_alu.sv:18$206 in module $paramod\addition_1\M=8\K=8.
Removed 3 dead cases from process $proc$new_alu.sv:642$199 in module synth_new_alu.
Marked 8 switch rules as full_case in process $proc$new_alu.sv:642$199 in module synth_new_alu.
Removed a total of 3 dead cases.

3.2.3. Executing PROC_INIT pass (extract init attributes).

3.2.4. Executing PROC_ARST pass (detect async resets in processes).

3.2.5. Executing PROC_MUX pass (convert decision trees to multiplexers).
Creating decoders for process `$paramod\right_shift_2\M=8\K=8.$proc$new_alu.sv:305$378'.
     1/24: $5\cache_status[1:1]
     2/24: $8\x[31:0]
     3/24: $7\x[31:0]
     4/24: $6\x[31:0]
     5/24: $5\x[31:0]
     6/24: $4\x[31:0]
     7/24: $3\x[31:0]
     8/24: $2\x[31:0]
     9/24: $1\x[31:0]
    10/24: $4\cache_status[2:2]
    11/24: $2\cache_result[7:0]
    12/24: $3\cache_status[3:3]
    13/24: $2\cache_status[3:3]
    14/24: $1\cache_result[7:0]
    15/24: $1\s_s[7:0]
    16/24: $1\cache_status[0:0]
    17/24: $0\cache_status[3:0] [1]
    18/24: $0\a[31:0]
    19/24: $0\x[31:0]
    20/24: $0\cache_status[3:0] [2]
    21/24: $0\s_s[7:0]
    22/24: $0\cache_status[3:0] [3]
    23/24: $0\cache_status[3:0] [0]
    24/24: $0\cache_result[7:0]
Creating decoders for process `$paramod\division\M=8\K=8.$proc$new_alu.sv:253$345'.
     1/24: $5\cache_status[1:1]
     2/24: $8\x[31:0]
     3/24: $7\x[31:0]
     4/24: $6\x[31:0]
     5/24: $5\x[31:0]
     6/24: $4\x[31:0]
     7/24: $3\x[31:0]
     8/24: $2\x[31:0]
     9/24: $1\x[31:0]
    10/24: $4\cache_status[2:2]
    11/24: $2\cache_result[7:0]
    12/24: $3\cache_status[3:3]
    13/24: $2\cache_status[3:3]
    14/24: $1\cache_result[7:0]
    15/24: $1\s_divid[7:0]
    16/24: $1\cache_status[0:0]
    17/24: $0\cache_status[3:0] [1]
    18/24: $0\a[31:0]
    19/24: $0\x[31:0]
    20/24: $0\cache_status[3:0] [2]
    21/24: $0\s_divid[7:0]
    22/24: $0\cache_status[3:0] [3]
    23/24: $0\cache_status[3:0] [0]
    24/24: $0\cache_result[7:0]
Creating decoders for process `$paramod\comparison_1\M=8\K=8.$proc$new_alu.sv:223$317'.
     1/8: $2\cache_status[3:3]
     2/8: $1\cache_status[3:3]
     3/8: $1\cache_result[7:0]
     4/8: $0\cache_status[3:0] [3]
     5/8: $0\cache_result[7:0]
     6/8: $0\x[31:0]
     7/8: $0\a[31:0]
     8/8: $0\cache_status[3:0] [2:0]
Creating decoders for process `$paramod\absolute\M=8\K=8.$proc$new_alu.sv:172$290'.
     1/19: $3\cache_status[0:0]
     2/19: $2\cache_status[1:1]
     3/19: $8\x[31:0]
     4/19: $7\x[31:0]
     5/19: $6\x[31:0]
     6/19: $5\x[31:0]
     7/19: $4\x[31:0]
     8/19: $3\x[31:0]
     9/19: $2\x[31:0]
    10/19: $1\x[31:0]
    11/19: $1\cache_status[2:2]
    12/19: $1\cache_result[7:0]
    13/19: $0\cache_status[3:0] [0]
    14/19: $0\cache_status[3:0] [1]
    15/19: $0\a[31:0]
    16/19: $0\x[31:0]
    17/19: $0\cache_status[3:0] [2]
    18/19: $0\cache_result[7:0]
    19/19: $0\cache_status[3:0] [3]
Creating decoders for process `$paramod\u2_to_zm\M=8\K=8.$proc$new_alu.sv:537$275'.
     1/5: $2\cache_result[7:0]
     2/5: $1\cache_result[7:0]
     3/5: $1\cache_status[3:0]
     4/5: $0\cache_status[3:0]
     5/5: $0\cache_result[7:0]
Creating decoders for process `$paramod\add_bit\M=8\K=8.$proc$new_alu.sv:361$266'.
     1/11: $2\cache_result[7:0]
     2/11: $2\cache_status[3:0]
     3/11: $2\sum[7:0]
     4/11: $1\cache_result[7:0]
     5/11: $1\cache_status[3:0]
     6/11: $1\sum[7:0]
     7/11: $0\sum[7:0]
     8/11: $0\cache_status[3:0]
     9/11: $0\cache_result[7:0]
    10/11: $0\s_B[7:0]
    11/11: $0\s_A[7:0]
Creating decoders for process `$paramod\comparison_2\M=8\K=8.$proc$new_alu.sv:411$249'.
     1/20: $4\comp_B[7:0] [7]
     2/20: $5\cache_result[7:0]
     3/20: $4\comp_B[7:0] [6:0]
     4/20: $4\comp_A[7:0] [6:0]
     5/20: $4\comp_A[7:0] [7]
     6/20: $6\cache_result[7:0]
     7/20: $4\cache_result[7:0]
     8/20: $3\cache_result[7:0]
     9/20: $3\comp_B[7:0]
    10/20: $3\comp_A[7:0]
    11/20: $2\cache_result[7:0]
    12/20: $2\comp_B[7:0]
    13/20: $2\comp_A[7:0]
    14/20: $1\cache_result[7:0]
    15/20: $1\comp_B[7:0]
    16/20: $1\comp_A[7:0]
    17/20: $0\comp_B[7:0]
    18/20: $0\comp_A[7:0]
    19/20: $0\cache_result[7:0]
    20/20: $0\cache_status[3:0]
Creating decoders for process `$paramod\sub_and_mul\M=8\K=8.$proc$new_alu.sv:488$242'.
     1/12: $2\cache_result[7:0]
     2/12: $2\cache_status[3:0]
     3/12: $2\sum[7:0]
     4/12: $1\cache_result[7:0]
     5/12: $1\cache_status[3:0]
     6/12: $1\sum[7:0]
     7/12: $0\sum[7:0]
     8/12: $0\cache_status[3:0]
     9/12: $0\cache_result[7:0]
    10/12: $0\s_B[7:0]
    11/12: $0\s_A[7:0]
    12/12: $0\cache[7:0]
Creating decoders for process `$paramod\zm_to_u2\M=8\K=8.$proc$new_alu.sv:142$238'.
     1/3: $1\cache_result[7:0]
     2/3: $0\cache_result[7:0]
     3/3: $0\cache_status[3:0]
Creating decoders for process `$paramod\right_shift_1\M=8\K=8.$proc$new_alu.sv:111$234'.
     1/4: $1\cache_result[7:0]
     2/4: $1\cache_status[3:0]
     3/4: $0\cache_status[3:0]
     4/4: $0\cache_result[7:0]
Creating decoders for process `$paramod\division_1\M=8\K=8.$proc$new_alu.sv:82$230'.
     1/4: $1\cache_result[7:0]
     2/4: $1\cache_status[3:0]
     3/4: $0\cache_status[3:0]
     4/4: $0\cache_result[7:0]
Creating decoders for process `$paramod\addition_1\M=8\K=8.$proc$new_alu.sv:18$206'.
     1/18: $8\cache_result[7:0]
     2/18: $4\cache_status[3:0]
     3/18: $3\cache_status[3:0]
     4/18: $7\cache_result[7:0]
     5/18: $2\cache[8:0]
     6/18: $6\cache_result[7:0]
     7/18: $5\cache_result[7:0]
     8/18: $4\cache_result[7:0]
     9/18: $3\cache_result[7:0]
    10/18: $2\cache_result[7:0]
    11/18: $2\cache_status[3:0]
    12/18: $1\cache_status[3:0]
    13/18: $1\cache_result[7:0]
    14/18: $1\cache[8:0]
    15/18: $0\cache_status[3:0]
    16/18: $0\cache_result[7:0]
    17/18: $0\cache[8:0]
    18/18: $0\cache_B[7:0]
Creating decoders for process `\synth_new_alu.$proc$new_alu.sv:642$199'.
     1/18: $1\cache_alu_error[0:0]
     2/18: $1\cache_op_ready[0:0]
     3/18: $5\finale_cache_result[7:0]
     4/18: $7\finale_cache_status[3:0]
     5/18: $6\finale_cache_status[2:2]
     6/18: $5\finale_cache_status[1:1]
     7/18: $4\finale_cache_result[7:0]
     8/18: $4\finale_cache_status[3:0]
     9/18: $3\finale_cache_result[7:0]
    10/18: $3\finale_cache_status[3:0]
    11/18: $2\finale_cache_result[7:0]
    12/18: $2\finale_cache_status[3:0]
    13/18: $1\finale_cache_status[3:0]
    14/18: $1\finale_cache_result[7:0]
    15/18: $0\cache_alu_error[0:0]
    16/18: $0\cache_op_ready[0:0]
    17/18: $0\finale_cache_status[3:0]
    18/18: $0\finale_cache_result[7:0]
Creating decoders for process `\synth_new_alu.$proc$new_alu.sv:777$205'.
     1/4: $0\o_alu_error[0:0]
     2/4: $0\o_op_rdy[0:0]
     3/4: $0\o_status[3:0]
     4/4: $0\o_result[7:0]

3.2.6. Executing PROC_DLATCH pass (convert process syncs to latches).
No latch inferred for signal `$paramod\right_shift_2\M=8\K=8.\cache_result' from process `$paramod\right_shift_2\M=8\K=8.$proc$new_alu.sv:305$378'.
No latch inferred for signal `$paramod\right_shift_2\M=8\K=8.\cache_status' from process `$paramod\right_shift_2\M=8\K=8.$proc$new_alu.sv:305$378'.
No latch inferred for signal `$paramod\right_shift_2\M=8\K=8.\a' from process `$paramod\right_shift_2\M=8\K=8.$proc$new_alu.sv:305$378'.
No latch inferred for signal `$paramod\right_shift_2\M=8\K=8.\x' from process `$paramod\right_shift_2\M=8\K=8.$proc$new_alu.sv:305$378'.
Latch inferred for signal `$paramod\right_shift_2\M=8\K=8.\s_s' from process `$paramod\right_shift_2\M=8\K=8.$proc$new_alu.sv:305$378': $auto$proc_dlatch.cc:409:proc_dlatch$934
No latch inferred for signal `$paramod\division\M=8\K=8.\cache_result' from process `$paramod\division\M=8\K=8.$proc$new_alu.sv:253$345'.
No latch inferred for signal `$paramod\division\M=8\K=8.\cache_status' from process `$paramod\division\M=8\K=8.$proc$new_alu.sv:253$345'.
No latch inferred for signal `$paramod\division\M=8\K=8.\a' from process `$paramod\division\M=8\K=8.$proc$new_alu.sv:253$345'.
No latch inferred for signal `$paramod\division\M=8\K=8.\x' from process `$paramod\division\M=8\K=8.$proc$new_alu.sv:253$345'.
Latch inferred for signal `$paramod\division\M=8\K=8.\s_divid' from process `$paramod\division\M=8\K=8.$proc$new_alu.sv:253$345': $auto$proc_dlatch.cc:409:proc_dlatch$945
No latch inferred for signal `$paramod\comparison_1\M=8\K=8.\cache_result' from process `$paramod\comparison_1\M=8\K=8.$proc$new_alu.sv:223$317'.
No latch inferred for signal `$paramod\comparison_1\M=8\K=8.\cache_status' from process `$paramod\comparison_1\M=8\K=8.$proc$new_alu.sv:223$317'.
No latch inferred for signal `$paramod\comparison_1\M=8\K=8.\a' from process `$paramod\comparison_1\M=8\K=8.$proc$new_alu.sv:223$317'.
No latch inferred for signal `$paramod\comparison_1\M=8\K=8.\x' from process `$paramod\comparison_1\M=8\K=8.$proc$new_alu.sv:223$317'.
No latch inferred for signal `$paramod\absolute\M=8\K=8.\cache_result' from process `$paramod\absolute\M=8\K=8.$proc$new_alu.sv:172$290'.
No latch inferred for signal `$paramod\absolute\M=8\K=8.\cache_status' from process `$paramod\absolute\M=8\K=8.$proc$new_alu.sv:172$290'.
No latch inferred for signal `$paramod\absolute\M=8\K=8.\a' from process `$paramod\absolute\M=8\K=8.$proc$new_alu.sv:172$290'.
No latch inferred for signal `$paramod\absolute\M=8\K=8.\x' from process `$paramod\absolute\M=8\K=8.$proc$new_alu.sv:172$290'.
No latch inferred for signal `$paramod\u2_to_zm\M=8\K=8.\cache_result' from process `$paramod\u2_to_zm\M=8\K=8.$proc$new_alu.sv:537$275'.
No latch inferred for signal `$paramod\u2_to_zm\M=8\K=8.\cache_status' from process `$paramod\u2_to_zm\M=8\K=8.$proc$new_alu.sv:537$275'.
No latch inferred for signal `$paramod\add_bit\M=8\K=8.\cache_result' from process `$paramod\add_bit\M=8\K=8.$proc$new_alu.sv:361$266'.
No latch inferred for signal `$paramod\add_bit\M=8\K=8.\cache_status' from process `$paramod\add_bit\M=8\K=8.$proc$new_alu.sv:361$266'.
No latch inferred for signal `$paramod\add_bit\M=8\K=8.\s_B' from process `$paramod\add_bit\M=8\K=8.$proc$new_alu.sv:361$266'.
No latch inferred for signal `$paramod\add_bit\M=8\K=8.\s_A' from process `$paramod\add_bit\M=8\K=8.$proc$new_alu.sv:361$266'.
Latch inferred for signal `$paramod\add_bit\M=8\K=8.\sum' from process `$paramod\add_bit\M=8\K=8.$proc$new_alu.sv:361$266': $auto$proc_dlatch.cc:409:proc_dlatch$974
No latch inferred for signal `$paramod\comparison_2\M=8\K=8.\cache_result' from process `$paramod\comparison_2\M=8\K=8.$proc$new_alu.sv:411$249'.
No latch inferred for signal `$paramod\comparison_2\M=8\K=8.\cache_status' from process `$paramod\comparison_2\M=8\K=8.$proc$new_alu.sv:411$249'.
Latch inferred for signal `$paramod\comparison_2\M=8\K=8.\comp_A' from process `$paramod\comparison_2\M=8\K=8.$proc$new_alu.sv:411$249': $auto$proc_dlatch.cc:409:proc_dlatch$1069
Latch inferred for signal `$paramod\comparison_2\M=8\K=8.\comp_B' from process `$paramod\comparison_2\M=8\K=8.$proc$new_alu.sv:411$249': $auto$proc_dlatch.cc:409:proc_dlatch$1072
No latch inferred for signal `$paramod\sub_and_mul\M=8\K=8.\cache' from process `$paramod\sub_and_mul\M=8\K=8.$proc$new_alu.sv:488$242'.
No latch inferred for signal `$paramod\sub_and_mul\M=8\K=8.\cache_result' from process `$paramod\sub_and_mul\M=8\K=8.$proc$new_alu.sv:488$242'.
No latch inferred for signal `$paramod\sub_and_mul\M=8\K=8.\cache_status' from process `$paramod\sub_and_mul\M=8\K=8.$proc$new_alu.sv:488$242'.
No latch inferred for signal `$paramod\sub_and_mul\M=8\K=8.\s_B' from process `$paramod\sub_and_mul\M=8\K=8.$proc$new_alu.sv:488$242'.
No latch inferred for signal `$paramod\sub_and_mul\M=8\K=8.\s_A' from process `$paramod\sub_and_mul\M=8\K=8.$proc$new_alu.sv:488$242'.
Latch inferred for signal `$paramod\sub_and_mul\M=8\K=8.\sum' from process `$paramod\sub_and_mul\M=8\K=8.$proc$new_alu.sv:488$242': $auto$proc_dlatch.cc:409:proc_dlatch$1101
No latch inferred for signal `$paramod\zm_to_u2\M=8\K=8.\cache_result' from process `$paramod\zm_to_u2\M=8\K=8.$proc$new_alu.sv:142$238'.
No latch inferred for signal `$paramod\zm_to_u2\M=8\K=8.\cache_status' from process `$paramod\zm_to_u2\M=8\K=8.$proc$new_alu.sv:142$238'.
No latch inferred for signal `$paramod\right_shift_1\M=8\K=8.\cache_result' from process `$paramod\right_shift_1\M=8\K=8.$proc$new_alu.sv:111$234'.
No latch inferred for signal `$paramod\right_shift_1\M=8\K=8.\cache_status' from process `$paramod\right_shift_1\M=8\K=8.$proc$new_alu.sv:111$234'.
No latch inferred for signal `$paramod\division_1\M=8\K=8.\cache_result' from process `$paramod\division_1\M=8\K=8.$proc$new_alu.sv:82$230'.
No latch inferred for signal `$paramod\division_1\M=8\K=8.\cache_status' from process `$paramod\division_1\M=8\K=8.$proc$new_alu.sv:82$230'.
No latch inferred for signal `$paramod\addition_1\M=8\K=8.\cache_B' from process `$paramod\addition_1\M=8\K=8.$proc$new_alu.sv:18$206'.
No latch inferred for signal `$paramod\addition_1\M=8\K=8.\cache_result' from process `$paramod\addition_1\M=8\K=8.$proc$new_alu.sv:18$206'.
No latch inferred for signal `$paramod\addition_1\M=8\K=8.\cache_status' from process `$paramod\addition_1\M=8\K=8.$proc$new_alu.sv:18$206'.
Latch inferred for signal `$paramod\addition_1\M=8\K=8.\cache' from process `$paramod\addition_1\M=8\K=8.$proc$new_alu.sv:18$206': $auto$proc_dlatch.cc:409:proc_dlatch$1120
No latch inferred for signal `\synth_new_alu.\finale_cache_result' from process `\synth_new_alu.$proc$new_alu.sv:642$199'.
No latch inferred for signal `\synth_new_alu.\finale_cache_status' from process `\synth_new_alu.$proc$new_alu.sv:642$199'.
No latch inferred for signal `\synth_new_alu.\cache_op_ready' from process `\synth_new_alu.$proc$new_alu.sv:642$199'.
No latch inferred for signal `\synth_new_alu.\cache_alu_error' from process `\synth_new_alu.$proc$new_alu.sv:642$199'.

3.2.7. Executing PROC_DFF pass (convert process syncs to FFs).
Creating register for signal `\synth_new_alu.\o_status' using process `\synth_new_alu.$proc$new_alu.sv:777$205'.
  created $dff cell `$procdff$1121' with positive edge clock.
Creating register for signal `\synth_new_alu.\o_op_rdy' using process `\synth_new_alu.$proc$new_alu.sv:777$205'.
  created $dff cell `$procdff$1122' with positive edge clock.
Creating register for signal `\synth_new_alu.\o_alu_error' using process `\synth_new_alu.$proc$new_alu.sv:777$205'.
  created $dff cell `$procdff$1123' with positive edge clock.
Creating register for signal `\synth_new_alu.\o_result' using process `\synth_new_alu.$proc$new_alu.sv:777$205'.
  created $dff cell `$procdff$1124' with positive edge clock.

3.2.8. Executing PROC_CLEAN pass (remove empty switches from decision trees).
Found and cleaned up 12 empty switches in `$paramod\right_shift_2\M=8\K=8.$proc$new_alu.sv:305$378'.
Removing empty process `$paramod\right_shift_2\M=8\K=8.$proc$new_alu.sv:305$378'.
Found and cleaned up 12 empty switches in `$paramod\division\M=8\K=8.$proc$new_alu.sv:253$345'.
Removing empty process `$paramod\division\M=8\K=8.$proc$new_alu.sv:253$345'.
Found and cleaned up 2 empty switches in `$paramod\comparison_1\M=8\K=8.$proc$new_alu.sv:223$317'.
Removing empty process `$paramod\comparison_1\M=8\K=8.$proc$new_alu.sv:223$317'.
Found and cleaned up 12 empty switches in `$paramod\absolute\M=8\K=8.$proc$new_alu.sv:172$290'.
Removing empty process `$paramod\absolute\M=8\K=8.$proc$new_alu.sv:172$290'.
Found and cleaned up 2 empty switches in `$paramod\u2_to_zm\M=8\K=8.$proc$new_alu.sv:537$275'.
Removing empty process `$paramod\u2_to_zm\M=8\K=8.$proc$new_alu.sv:537$275'.
Found and cleaned up 2 empty switches in `$paramod\add_bit\M=8\K=8.$proc$new_alu.sv:361$266'.
Removing empty process `$paramod\add_bit\M=8\K=8.$proc$new_alu.sv:361$266'.
Found and cleaned up 6 empty switches in `$paramod\comparison_2\M=8\K=8.$proc$new_alu.sv:411$249'.
Removing empty process `$paramod\comparison_2\M=8\K=8.$proc$new_alu.sv:411$249'.
Found and cleaned up 2 empty switches in `$paramod\sub_and_mul\M=8\K=8.$proc$new_alu.sv:488$242'.
Removing empty process `$paramod\sub_and_mul\M=8\K=8.$proc$new_alu.sv:488$242'.
Found and cleaned up 1 empty switch in `$paramod\zm_to_u2\M=8\K=8.$proc$new_alu.sv:142$238'.
Removing empty process `$paramod\zm_to_u2\M=8\K=8.$proc$new_alu.sv:142$238'.
Found and cleaned up 1 empty switch in `$paramod\right_shift_1\M=8\K=8.$proc$new_alu.sv:111$234'.
Removing empty process `$paramod\right_shift_1\M=8\K=8.$proc$new_alu.sv:111$234'.
Found and cleaned up 1 empty switch in `$paramod\division_1\M=8\K=8.$proc$new_alu.sv:82$230'.
Removing empty process `$paramod\division_1\M=8\K=8.$proc$new_alu.sv:82$230'.
Found and cleaned up 8 empty switches in `$paramod\addition_1\M=8\K=8.$proc$new_alu.sv:18$206'.
Removing empty process `$paramod\addition_1\M=8\K=8.$proc$new_alu.sv:18$206'.
Found and cleaned up 8 empty switches in `\synth_new_alu.$proc$new_alu.sv:642$199'.
Removing empty process `synth_new_alu.$proc$new_alu.sv:642$199'.
Removing empty process `synth_new_alu.$proc$new_alu.sv:777$205'.
Cleaned up 69 empty switches.

3.3. Executing OPT_EXPR pass (perform const folding).
Optimizing module $paramod\right_shift_2\M=8\K=8.
<suppressed ~18 debug messages>
Optimizing module $paramod\division\M=8\K=8.
<suppressed ~18 debug messages>
Optimizing module $paramod\comparison_1\M=8\K=8.
<suppressed ~15 debug messages>
Optimizing module $paramod\absolute\M=8\K=8.
<suppressed ~13 debug messages>
Optimizing module $paramod\u2_to_zm\M=8\K=8.
<suppressed ~1 debug messages>
Optimizing module $paramod\add_bit\M=8\K=8.
<suppressed ~11 debug messages>
Optimizing module $paramod\comparison_2\M=8\K=8.
<suppressed ~60 debug messages>
Optimizing module $paramod\sub_and_mul\M=8\K=8.
<suppressed ~12 debug messages>
Optimizing module $paramod\zm_to_u2\M=8\K=8.
<suppressed ~2 debug messages>
Optimizing module $paramod\right_shift_1\M=8\K=8.
<suppressed ~3 debug messages>
Optimizing module $paramod\division_1\M=8\K=8.
<suppressed ~1 debug messages>
Optimizing module $paramod\addition_1\M=8\K=8.
<suppressed ~16 debug messages>
Optimizing module synth_new_alu.
<suppressed ~16 debug messages>

3.4. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module $paramod\right_shift_2\M=8\K=8..
Finding unused cells or wires in module $paramod\division\M=8\K=8..
Finding unused cells or wires in module $paramod\comparison_1\M=8\K=8..
Finding unused cells or wires in module $paramod\absolute\M=8\K=8..
Finding unused cells or wires in module $paramod\u2_to_zm\M=8\K=8..
Finding unused cells or wires in module $paramod\add_bit\M=8\K=8..
Finding unused cells or wires in module $paramod\comparison_2\M=8\K=8..
Finding unused cells or wires in module $paramod\sub_and_mul\M=8\K=8..
Finding unused cells or wires in module $paramod\zm_to_u2\M=8\K=8..
Finding unused cells or wires in module $paramod\right_shift_1\M=8\K=8..
Finding unused cells or wires in module $paramod\division_1\M=8\K=8..
Finding unused cells or wires in module $paramod\addition_1\M=8\K=8..
Finding unused cells or wires in module \synth_new_alu..
Removed 56 unused cells and 549 unused wires.
<suppressed ~76 debug messages>

3.5. Executing CHECK pass (checking for obvious problems).
checking module $paramod\absolute\M=8\K=8..
checking module $paramod\add_bit\M=8\K=8..
checking module $paramod\addition_1\M=8\K=8..
checking module $paramod\comparison_1\M=8\K=8..
checking module $paramod\comparison_2\M=8\K=8..
checking module $paramod\division\M=8\K=8..
checking module $paramod\division_1\M=8\K=8..
checking module $paramod\right_shift_1\M=8\K=8..
checking module $paramod\right_shift_2\M=8\K=8..
checking module $paramod\sub_and_mul\M=8\K=8..
checking module $paramod\u2_to_zm\M=8\K=8..
checking module $paramod\zm_to_u2\M=8\K=8..
checking module synth_new_alu..
found and reported 0 problems.

3.6. Executing OPT pass (performing simple optimizations).

3.6.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module $paramod\absolute\M=8\K=8.
Optimizing module $paramod\add_bit\M=8\K=8.
Optimizing module $paramod\addition_1\M=8\K=8.
Optimizing module $paramod\comparison_1\M=8\K=8.
Optimizing module $paramod\comparison_2\M=8\K=8.
Optimizing module $paramod\division\M=8\K=8.
Optimizing module $paramod\division_1\M=8\K=8.
Optimizing module $paramod\right_shift_1\M=8\K=8.
Optimizing module $paramod\right_shift_2\M=8\K=8.
Optimizing module $paramod\sub_and_mul\M=8\K=8.
Optimizing module $paramod\u2_to_zm\M=8\K=8.
Optimizing module $paramod\zm_to_u2\M=8\K=8.
Optimizing module synth_new_alu.

3.6.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `$paramod\absolute\M=8\K=8'.
Finding identical cells in module `$paramod\add_bit\M=8\K=8'.
<suppressed ~3 debug messages>
Finding identical cells in module `$paramod\addition_1\M=8\K=8'.
<suppressed ~15 debug messages>
Finding identical cells in module `$paramod\comparison_1\M=8\K=8'.
Finding identical cells in module `$paramod\comparison_2\M=8\K=8'.
<suppressed ~6 debug messages>
Finding identical cells in module `$paramod\division\M=8\K=8'.
Finding identical cells in module `$paramod\division_1\M=8\K=8'.
Finding identical cells in module `$paramod\right_shift_1\M=8\K=8'.
Finding identical cells in module `$paramod\right_shift_2\M=8\K=8'.
Finding identical cells in module `$paramod\sub_and_mul\M=8\K=8'.
<suppressed ~3 debug messages>
Finding identical cells in module `$paramod\u2_to_zm\M=8\K=8'.
<suppressed ~6 debug messages>
Finding identical cells in module `$paramod\zm_to_u2\M=8\K=8'.
Finding identical cells in module `\synth_new_alu'.
<suppressed ~87 debug messages>
Removed a total of 40 cells.

3.6.3. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module $paramod\absolute\M=8\K=8..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module $paramod\add_bit\M=8\K=8..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
    dead port 1/2 on $mux $procmux$576.
    dead port 1/2 on $mux $procmux$582.
Running muxtree optimizer on module $paramod\addition_1\M=8\K=8..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
      Replacing known input bits on port A of cell $procmux$823: $1\cache[8:0] [7:0] -> { 1'0 $1\cache[8:0] [6:0] }
  Analyzing evaluation results.
    dead port 2/2 on $mux $procmux$786.
    dead port 2/2 on $mux $procmux$792.
    dead port 2/2 on $mux $procmux$807.
    dead port 2/2 on $mux $procmux$816.
    dead port 2/2 on $mux $procmux$825.
    dead port 2/2 on $mux $procmux$831.
Running muxtree optimizer on module $paramod\comparison_1\M=8\K=8..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
    dead port 2/2 on $mux $procmux$516.
Running muxtree optimizer on module $paramod\comparison_2\M=8\K=8..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
    dead port 1/2 on $mux $procmux$615.
    dead port 1/2 on $mux $procmux$618.
    dead port 1/2 on $mux $procmux$621.
    dead port 2/2 on $mux $procmux$663.
    dead port 1/2 on $mux $procmux$666.
    dead port 1/2 on $mux $procmux$669.
    dead port 1/2 on $mux $procmux$672.
    dead port 2/2 on $mux $procmux$678.
    dead port 1/2 on $mux $procmux$681.
    dead port 1/2 on $mux $procmux$684.
    dead port 1/2 on $mux $procmux$690.
    dead port 1/2 on $mux $procmux$693.
    dead port 1/2 on $mux $procmux$717.
Running muxtree optimizer on module $paramod\division\M=8\K=8..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
    dead port 2/2 on $mux $procmux$492.
    dead port 2/2 on $mux $procmux$498.
Running muxtree optimizer on module $paramod\division_1\M=8\K=8..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module $paramod\right_shift_1\M=8\K=8..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module $paramod\right_shift_2\M=8\K=8..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
    dead port 2/2 on $mux $procmux$438.
    dead port 2/2 on $mux $procmux$444.
Running muxtree optimizer on module $paramod\sub_and_mul\M=8\K=8..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
    dead port 1/2 on $mux $procmux$744.
    dead port 1/2 on $mux $procmux$750.
Running muxtree optimizer on module $paramod\u2_to_zm\M=8\K=8..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
      Replacing known input bits on port A of cell $procmux$561: \i_arg_A -> { 1'0 \i_arg_A [6:0] }
  Analyzing evaluation results.
    dead port 1/2 on $mux $procmux$564.
Running muxtree optimizer on module $paramod\zm_to_u2\M=8\K=8..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
      Replacing known input bits on port A of cell $procmux$768: \i_arg_A -> { 1'0 \i_arg_A [6:0] }
  Analyzing evaluation results.
Running muxtree optimizer on module \synth_new_alu..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
    dead port 2/2 on $mux $procmux$883.
    dead port 2/2 on $mux $procmux$892.
    dead port 2/2 on $mux $procmux$866.
    dead port 2/2 on $mux $procmux$902.
    dead port 2/2 on $mux $procmux$912.
    dead port 2/2 on $mux $procmux$874.
Removed 35 multiplexer ports.
<suppressed ~61 debug messages>

3.6.4. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
  Optimizing cells in module $paramod\absolute\M=8\K=8.
  Optimizing cells in module $paramod\add_bit\M=8\K=8.
  Optimizing cells in module $paramod\addition_1\M=8\K=8.
  Optimizing cells in module $paramod\comparison_1\M=8\K=8.
  Optimizing cells in module $paramod\comparison_2\M=8\K=8.
  Optimizing cells in module $paramod\division\M=8\K=8.
  Optimizing cells in module $paramod\division_1\M=8\K=8.
  Optimizing cells in module $paramod\right_shift_1\M=8\K=8.
  Optimizing cells in module $paramod\right_shift_2\M=8\K=8.
  Optimizing cells in module $paramod\sub_and_mul\M=8\K=8.
  Optimizing cells in module $paramod\u2_to_zm\M=8\K=8.
  Optimizing cells in module $paramod\zm_to_u2\M=8\K=8.
  Optimizing cells in module \synth_new_alu.
Performed a total of 0 changes.

3.6.5. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `$paramod\absolute\M=8\K=8'.
Finding identical cells in module `$paramod\add_bit\M=8\K=8'.
Finding identical cells in module `$paramod\addition_1\M=8\K=8'.
Finding identical cells in module `$paramod\comparison_1\M=8\K=8'.
Finding identical cells in module `$paramod\comparison_2\M=8\K=8'.
Finding identical cells in module `$paramod\division\M=8\K=8'.
Finding identical cells in module `$paramod\division_1\M=8\K=8'.
Finding identical cells in module `$paramod\right_shift_1\M=8\K=8'.
Finding identical cells in module `$paramod\right_shift_2\M=8\K=8'.
Finding identical cells in module `$paramod\sub_and_mul\M=8\K=8'.
Finding identical cells in module `$paramod\u2_to_zm\M=8\K=8'.
Finding identical cells in module `$paramod\zm_to_u2\M=8\K=8'.
Finding identical cells in module `\synth_new_alu'.
Removed a total of 0 cells.

3.6.6. Executing OPT_RMDFF pass (remove dff with constant values).

3.6.7. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module $paramod\absolute\M=8\K=8..
Finding unused cells or wires in module $paramod\add_bit\M=8\K=8..
Finding unused cells or wires in module $paramod\addition_1\M=8\K=8..
Finding unused cells or wires in module $paramod\comparison_1\M=8\K=8..
Finding unused cells or wires in module $paramod\comparison_2\M=8\K=8..
Finding unused cells or wires in module $paramod\division\M=8\K=8..
Finding unused cells or wires in module $paramod\division_1\M=8\K=8..
Finding unused cells or wires in module $paramod\right_shift_1\M=8\K=8..
Finding unused cells or wires in module $paramod\right_shift_2\M=8\K=8..
Finding unused cells or wires in module $paramod\sub_and_mul\M=8\K=8..
Finding unused cells or wires in module $paramod\u2_to_zm\M=8\K=8..
Finding unused cells or wires in module $paramod\zm_to_u2\M=8\K=8..
Finding unused cells or wires in module \synth_new_alu..
Removed 0 unused cells and 75 unused wires.
<suppressed ~9 debug messages>

3.6.8. Executing OPT_EXPR pass (perform const folding).
Optimizing module $paramod\absolute\M=8\K=8.
Optimizing module $paramod\add_bit\M=8\K=8.
Optimizing module $paramod\addition_1\M=8\K=8.
Optimizing module $paramod\comparison_1\M=8\K=8.
Optimizing module $paramod\comparison_2\M=8\K=8.
Optimizing module $paramod\division\M=8\K=8.
Optimizing module $paramod\division_1\M=8\K=8.
Optimizing module $paramod\right_shift_1\M=8\K=8.
Optimizing module $paramod\right_shift_2\M=8\K=8.
Optimizing module $paramod\sub_and_mul\M=8\K=8.
Optimizing module $paramod\u2_to_zm\M=8\K=8.
Optimizing module $paramod\zm_to_u2\M=8\K=8.
Optimizing module synth_new_alu.

3.6.9. Rerunning OPT passes. (Maybe there is more to do..)

3.6.10. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module $paramod\absolute\M=8\K=8..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module $paramod\add_bit\M=8\K=8..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module $paramod\addition_1\M=8\K=8..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module $paramod\comparison_1\M=8\K=8..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module $paramod\comparison_2\M=8\K=8..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module $paramod\division\M=8\K=8..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module $paramod\division_1\M=8\K=8..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module $paramod\right_shift_1\M=8\K=8..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module $paramod\right_shift_2\M=8\K=8..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module $paramod\sub_and_mul\M=8\K=8..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module $paramod\u2_to_zm\M=8\K=8..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module $paramod\zm_to_u2\M=8\K=8..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \synth_new_alu..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Removed 0 multiplexer ports.
<suppressed ~61 debug messages>

3.6.11. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
  Optimizing cells in module $paramod\absolute\M=8\K=8.
  Optimizing cells in module $paramod\add_bit\M=8\K=8.
  Optimizing cells in module $paramod\addition_1\M=8\K=8.
  Optimizing cells in module $paramod\comparison_1\M=8\K=8.
  Optimizing cells in module $paramod\comparison_2\M=8\K=8.
  Optimizing cells in module $paramod\division\M=8\K=8.
  Optimizing cells in module $paramod\division_1\M=8\K=8.
  Optimizing cells in module $paramod\right_shift_1\M=8\K=8.
  Optimizing cells in module $paramod\right_shift_2\M=8\K=8.
  Optimizing cells in module $paramod\sub_and_mul\M=8\K=8.
  Optimizing cells in module $paramod\u2_to_zm\M=8\K=8.
  Optimizing cells in module $paramod\zm_to_u2\M=8\K=8.
  Optimizing cells in module \synth_new_alu.
Performed a total of 0 changes.

3.6.12. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `$paramod\absolute\M=8\K=8'.
Finding identical cells in module `$paramod\add_bit\M=8\K=8'.
Finding identical cells in module `$paramod\addition_1\M=8\K=8'.
Finding identical cells in module `$paramod\comparison_1\M=8\K=8'.
Finding identical cells in module `$paramod\comparison_2\M=8\K=8'.
Finding identical cells in module `$paramod\division\M=8\K=8'.
Finding identical cells in module `$paramod\division_1\M=8\K=8'.
Finding identical cells in module `$paramod\right_shift_1\M=8\K=8'.
Finding identical cells in module `$paramod\right_shift_2\M=8\K=8'.
Finding identical cells in module `$paramod\sub_and_mul\M=8\K=8'.
Finding identical cells in module `$paramod\u2_to_zm\M=8\K=8'.
Finding identical cells in module `$paramod\zm_to_u2\M=8\K=8'.
Finding identical cells in module `\synth_new_alu'.
Removed a total of 0 cells.

3.6.13. Executing OPT_RMDFF pass (remove dff with constant values).

3.6.14. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module $paramod\absolute\M=8\K=8..
Finding unused cells or wires in module $paramod\add_bit\M=8\K=8..
Finding unused cells or wires in module $paramod\addition_1\M=8\K=8..
Finding unused cells or wires in module $paramod\comparison_1\M=8\K=8..
Finding unused cells or wires in module $paramod\comparison_2\M=8\K=8..
Finding unused cells or wires in module $paramod\division\M=8\K=8..
Finding unused cells or wires in module $paramod\division_1\M=8\K=8..
Finding unused cells or wires in module $paramod\right_shift_1\M=8\K=8..
Finding unused cells or wires in module $paramod\right_shift_2\M=8\K=8..
Finding unused cells or wires in module $paramod\sub_and_mul\M=8\K=8..
Finding unused cells or wires in module $paramod\u2_to_zm\M=8\K=8..
Finding unused cells or wires in module $paramod\zm_to_u2\M=8\K=8..
Finding unused cells or wires in module \synth_new_alu..

3.6.15. Executing OPT_EXPR pass (perform const folding).
Optimizing module $paramod\absolute\M=8\K=8.
Optimizing module $paramod\add_bit\M=8\K=8.
Optimizing module $paramod\addition_1\M=8\K=8.
Optimizing module $paramod\comparison_1\M=8\K=8.
Optimizing module $paramod\comparison_2\M=8\K=8.
Optimizing module $paramod\division\M=8\K=8.
Optimizing module $paramod\division_1\M=8\K=8.
Optimizing module $paramod\right_shift_1\M=8\K=8.
Optimizing module $paramod\right_shift_2\M=8\K=8.
Optimizing module $paramod\sub_and_mul\M=8\K=8.
Optimizing module $paramod\u2_to_zm\M=8\K=8.
Optimizing module $paramod\zm_to_u2\M=8\K=8.
Optimizing module synth_new_alu.

3.6.16. Finished OPT passes. (There is nothing left to do.)

3.7. Executing WREDUCE pass (reducing word size of cells).
Removed top 31 bits (of 32) from mux cell $paramod\absolute\M=8\K=8.$procmux$552 ($mux).
Removed top 31 bits (of 32) from port B of cell $paramod\absolute\M=8\K=8.$ge$new_alu.sv:181$291 ($ge).
Removed top 30 bits (of 32) from port A of cell $paramod\absolute\M=8\K=8.$add$new_alu.sv:199$297 ($add).
Removed top 30 bits (of 32) from port B of cell $paramod\absolute\M=8\K=8.$add$new_alu.sv:199$297 ($add).
Converting cell $paramod\absolute\M=8\K=8.$add$new_alu.sv:199$297 ($add) from signed to unsigned.
Removed top 29 bits (of 32) from port Y of cell $paramod\absolute\M=8\K=8.$add$new_alu.sv:199$297 ($add).
Removed top 1 bits (of 2) from port A of cell $paramod\absolute\M=8\K=8.$add$new_alu.sv:199$297 ($add).
Removed top 1 bits (of 2) from port B of cell $paramod\absolute\M=8\K=8.$add$new_alu.sv:199$297 ($add).
Removed top 1 bits (of 3) from port Y of cell $paramod\absolute\M=8\K=8.$add$new_alu.sv:199$297 ($add).
Removed top 30 bits (of 32) from port B of cell $paramod\absolute\M=8\K=8.$add$new_alu.sv:199$299 ($add).
Removed top 30 bits (of 32) from port B of cell $paramod\absolute\M=8\K=8.$add$new_alu.sv:199$301 ($add).
Removed top 30 bits (of 32) from port B of cell $paramod\absolute\M=8\K=8.$add$new_alu.sv:199$303 ($add).
Removed top 30 bits (of 32) from port B of cell $paramod\absolute\M=8\K=8.$add$new_alu.sv:199$305 ($add).
Removed top 30 bits (of 32) from port B of cell $paramod\absolute\M=8\K=8.$add$new_alu.sv:199$307 ($add).
Removed top 30 bits (of 32) from port B of cell $paramod\absolute\M=8\K=8.$add$new_alu.sv:199$309 ($add).
Removed top 24 bits (of 32) from port B of cell $paramod\absolute\M=8\K=8.$lt$new_alu.sv:207$314 ($lt).
Removed top 23 bits (of 32) from port B of cell $paramod\absolute\M=8\K=8.$ge$new_alu.sv:207$315 ($ge).
Removed top 31 bits (of 32) from wire $paramod\absolute\M=8\K=8.$1\x[31:0].
Removed top 30 bits (of 32) from wire $paramod\absolute\M=8\K=8.$add$new_alu.sv:199$297_Y.
Removed cell $paramod\add_bit\M=8\K=8.$procmux$573 ($mux).
Removed cell $paramod\add_bit\M=8\K=8.$procmux$591 ($mux).
Removed top 24 bits (of 32) from port B of cell $paramod\add_bit\M=8\K=8.$lt$new_alu.sv:377$270 ($lt).
Removed top 24 bits (of 32) from port B of cell $paramod\add_bit\M=8\K=8.$gt$new_alu.sv:373$268 ($gt).
Removed top 23 bits (of 32) from port Y of cell $paramod\add_bit\M=8\K=8.$add$new_alu.sv:373$267 ($add).
Removed top 31 bits (of 32) from port A of cell $paramod\add_bit\M=8\K=8.$shl$new_alu.sv:390$272 ($shl).
Removed top 24 bits (of 32) from port Y of cell $paramod\add_bit\M=8\K=8.$and$new_alu.sv:390$274 ($and).
Removed top 24 bits (of 32) from port B of cell $paramod\add_bit\M=8\K=8.$and$new_alu.sv:390$274 ($and).
Removed top 24 bits (of 32) from port Y of cell $paramod\add_bit\M=8\K=8.$not$new_alu.sv:390$273 ($not).
Removed top 24 bits (of 32) from port A of cell $paramod\add_bit\M=8\K=8.$not$new_alu.sv:390$273 ($not).
Removed top 24 bits (of 32) from port Y of cell $paramod\add_bit\M=8\K=8.$shl$new_alu.sv:390$272 ($shl).
Removed top 24 bits (of 32) from wire $paramod\add_bit\M=8\K=8.$not$new_alu.sv:390$273_Y.
Removed top 24 bits (of 32) from wire $paramod\add_bit\M=8\K=8.$shl$new_alu.sv:390$272_Y.
Removed top 1 bits (of 9) from port Y of cell $paramod\addition_1\M=8\K=8.$add$new_alu.sv:30$211 ($add).
Removed top 1 bits (of 9) from port Y of cell $paramod\addition_1\M=8\K=8.$add$new_alu.sv:62$228 ($add).
Removed cell $paramod\addition_1\M=8\K=8.$procmux$784 ($mux).
Removed cell $paramod\addition_1\M=8\K=8.$procmux$823 ($mux).
Removed top 1 bits (of 8) from mux cell $paramod\addition_1\M=8\K=8.$procmux$837 ($mux).
Removed top 1 bits (of 9) from wire $paramod\addition_1\M=8\K=8.$1\cache[8:0].
Removed top 1 bits (of 8) from wire $paramod\addition_1\M=8\K=8.$2\cache_result[7:0].
Removed top 7 bits (of 8) from mux cell $paramod\comparison_1\M=8\K=8.$procmux$522 ($mux).
Removed top 31 bits (of 32) from port A of cell $paramod\comparison_1\M=8\K=8.$eq$new_alu.sv:234$321 ($eq).
Removed top 30 bits (of 32) from port B of cell $paramod\comparison_1\M=8\K=8.$eq$new_alu.sv:234$321 ($eq).
Removed top 31 bits (of 32) from port A of cell $paramod\comparison_1\M=8\K=8.$eq$new_alu.sv:234$323 ($eq).
Removed top 30 bits (of 32) from port B of cell $paramod\comparison_1\M=8\K=8.$eq$new_alu.sv:234$323 ($eq).
Removed top 7 bits (of 8) from mux cell $paramod\comparison_2\M=8\K=8.$procmux$676 ($mux).
Removed top 7 bits (of 8) from mux cell $paramod\comparison_2\M=8\K=8.$procmux$661 ($mux).
Removed top 1 bits (of 8) from port A of cell $paramod\comparison_2\M=8\K=8.$gt$new_alu.sv:455$265 ($gt).
Removed top 1 bits (of 8) from port B of cell $paramod\comparison_2\M=8\K=8.$gt$new_alu.sv:455$265 ($gt).
Removed top 7 bits (of 8) from wire $paramod\comparison_2\M=8\K=8.$4\cache_result[7:0].
Removed top 7 bits (of 8) from wire $paramod\comparison_2\M=8\K=8.$6\cache_result[7:0].
Removed top 31 bits (of 32) from mux cell $paramod\division\M=8\K=8.$procmux$483 ($mux).
Removed top 28 bits (of 32) from port B of cell $paramod\division\M=8\K=8.$le$new_alu.sv:266$348 ($le).
Removed top 31 bits (of 32) from port B of cell $paramod\division\M=8\K=8.$nex$new_alu.sv:262$346 ($nex).
Removed top 30 bits (of 32) from port A of cell $paramod\division\M=8\K=8.$add$new_alu.sv:284$353 ($add).
Removed top 30 bits (of 32) from port B of cell $paramod\division\M=8\K=8.$add$new_alu.sv:284$353 ($add).
Converting cell $paramod\division\M=8\K=8.$add$new_alu.sv:284$353 ($add) from signed to unsigned.
Removed top 29 bits (of 32) from port Y of cell $paramod\division\M=8\K=8.$add$new_alu.sv:284$353 ($add).
Removed top 1 bits (of 2) from port A of cell $paramod\division\M=8\K=8.$add$new_alu.sv:284$353 ($add).
Removed top 1 bits (of 2) from port B of cell $paramod\division\M=8\K=8.$add$new_alu.sv:284$353 ($add).
Removed top 1 bits (of 3) from port Y of cell $paramod\division\M=8\K=8.$add$new_alu.sv:284$353 ($add).
Removed top 30 bits (of 32) from port B of cell $paramod\division\M=8\K=8.$add$new_alu.sv:284$355 ($add).
Removed top 30 bits (of 32) from port B of cell $paramod\division\M=8\K=8.$add$new_alu.sv:284$357 ($add).
Removed top 30 bits (of 32) from port B of cell $paramod\division\M=8\K=8.$add$new_alu.sv:284$359 ($add).
Removed top 30 bits (of 32) from port B of cell $paramod\division\M=8\K=8.$add$new_alu.sv:284$361 ($add).
Removed top 30 bits (of 32) from port B of cell $paramod\division\M=8\K=8.$add$new_alu.sv:284$363 ($add).
Removed top 30 bits (of 32) from port B of cell $paramod\division\M=8\K=8.$add$new_alu.sv:284$365 ($add).
Removed top 31 bits (of 32) from wire $paramod\division\M=8\K=8.$1\x[31:0].
Removed top 30 bits (of 32) from wire $paramod\division\M=8\K=8.$add$new_alu.sv:284$353_Y.
Removed cell $paramod\division_1\M=8\K=8.$procmux$777 ($mux).
Removed cell $paramod\right_shift_1\M=8\K=8.$procmux$771 ($mux).
Removed top 31 bits (of 32) from mux cell $paramod\right_shift_2\M=8\K=8.$procmux$429 ($mux).
Removed top 29 bits (of 32) from port B of cell $paramod\right_shift_2\M=8\K=8.$le$new_alu.sv:320$382 ($le).
Removed top 31 bits (of 32) from port B of cell $paramod\right_shift_2\M=8\K=8.$ge$new_alu.sv:314$379 ($ge).
Removed top 30 bits (of 32) from port A of cell $paramod\right_shift_2\M=8\K=8.$add$new_alu.sv:338$387 ($add).
Removed top 30 bits (of 32) from port B of cell $paramod\right_shift_2\M=8\K=8.$add$new_alu.sv:338$387 ($add).
Converting cell $paramod\right_shift_2\M=8\K=8.$add$new_alu.sv:338$387 ($add) from signed to unsigned.
Removed top 29 bits (of 32) from port Y of cell $paramod\right_shift_2\M=8\K=8.$add$new_alu.sv:338$387 ($add).
Removed top 1 bits (of 2) from port A of cell $paramod\right_shift_2\M=8\K=8.$add$new_alu.sv:338$387 ($add).
Removed top 1 bits (of 2) from port B of cell $paramod\right_shift_2\M=8\K=8.$add$new_alu.sv:338$387 ($add).
Removed top 1 bits (of 3) from port Y of cell $paramod\right_shift_2\M=8\K=8.$add$new_alu.sv:338$387 ($add).
Removed top 30 bits (of 32) from port B of cell $paramod\right_shift_2\M=8\K=8.$add$new_alu.sv:338$389 ($add).
Removed top 30 bits (of 32) from port B of cell $paramod\right_shift_2\M=8\K=8.$add$new_alu.sv:338$391 ($add).
Removed top 30 bits (of 32) from port B of cell $paramod\right_shift_2\M=8\K=8.$add$new_alu.sv:338$393 ($add).
Removed top 30 bits (of 32) from port B of cell $paramod\right_shift_2\M=8\K=8.$add$new_alu.sv:338$395 ($add).
Removed top 30 bits (of 32) from port B of cell $paramod\right_shift_2\M=8\K=8.$add$new_alu.sv:338$397 ($add).
Removed top 30 bits (of 32) from port B of cell $paramod\right_shift_2\M=8\K=8.$add$new_alu.sv:338$399 ($add).
Removed top 31 bits (of 32) from wire $paramod\right_shift_2\M=8\K=8.$1\x[31:0].
Removed top 30 bits (of 32) from wire $paramod\right_shift_2\M=8\K=8.$add$new_alu.sv:338$387_Y.
Removed cell $paramod\sub_and_mul\M=8\K=8.$procmux$741 ($mux).
Removed top 24 bits (of 32) from port B of cell $paramod\sub_and_mul\M=8\K=8.$gt$new_alu.sv:501$245 ($gt).
Removed top 24 bits (of 32) from port B of cell $paramod\sub_and_mul\M=8\K=8.$lt$new_alu.sv:508$247 ($lt).
Removed cell $paramod\sub_and_mul\M=8\K=8.$procmux$759 ($mux).
Removed top 1 bits (of 2) from port B of cell synth_new_alu.$procmux$864_CMP0 ($eq).
Removed top 1 bits (of 2) from port B of cell synth_new_alu.$procmux$884_CMP0 ($eq).

3.8. Executing PEEPOPT pass (run peephole optimizers).

3.9. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module $paramod\absolute\M=8\K=8..
Finding unused cells or wires in module $paramod\add_bit\M=8\K=8..
Finding unused cells or wires in module $paramod\addition_1\M=8\K=8..
Finding unused cells or wires in module $paramod\comparison_1\M=8\K=8..
Finding unused cells or wires in module $paramod\comparison_2\M=8\K=8..
Finding unused cells or wires in module $paramod\division\M=8\K=8..
Finding unused cells or wires in module $paramod\division_1\M=8\K=8..
Finding unused cells or wires in module $paramod\right_shift_1\M=8\K=8..
Finding unused cells or wires in module $paramod\right_shift_2\M=8\K=8..
Finding unused cells or wires in module $paramod\sub_and_mul\M=8\K=8..
Finding unused cells or wires in module $paramod\u2_to_zm\M=8\K=8..
Finding unused cells or wires in module $paramod\zm_to_u2\M=8\K=8..
Finding unused cells or wires in module \synth_new_alu..
Removed 0 unused cells and 21 unused wires.
<suppressed ~9 debug messages>

3.10. Executing TECHMAP pass (map to technology primitives).

3.10.1. Executing Verilog-2005 frontend: /usr/bin/../share/yosys/cmp2lut.v
Parsing Verilog input from `/usr/bin/../share/yosys/cmp2lut.v' to AST representation.
Generating RTLIL representation for module `\_90_lut_cmp_'.
Successfully finished Verilog frontend.

3.10.2. Continuing TECHMAP pass.
No more expansions possible.
<suppressed ~292 debug messages>

3.11. Executing ALUMACC pass (create $alu and $macc cells).
Extracting $alu and $macc cells in module $paramod\absolute\M=8\K=8:
  creating $macc model for $add$new_alu.sv:199$297 ($add).
  creating $macc model for $add$new_alu.sv:199$299 ($add).
  creating $macc model for $add$new_alu.sv:199$301 ($add).
  creating $macc model for $add$new_alu.sv:199$303 ($add).
  creating $macc model for $add$new_alu.sv:199$305 ($add).
  creating $macc model for $add$new_alu.sv:199$307 ($add).
  creating $macc model for $add$new_alu.sv:199$309 ($add).
  creating $macc model for $neg$new_alu.sv:187$292 ($neg).
  creating $alu model for $macc $neg$new_alu.sv:187$292.
  creating $alu model for $macc $add$new_alu.sv:199$309.
  creating $alu model for $macc $add$new_alu.sv:199$307.
  creating $alu model for $macc $add$new_alu.sv:199$305.
  creating $alu model for $macc $add$new_alu.sv:199$303.
  creating $alu model for $macc $add$new_alu.sv:199$301.
  creating $alu model for $macc $add$new_alu.sv:199$299.
  creating $alu model for $macc $add$new_alu.sv:199$297.
  creating $alu model for $ge$new_alu.sv:181$291 ($ge): new $alu
  creating $alu model for $ge$new_alu.sv:207$315 ($ge): new $alu
  creating $alu model for $lt$new_alu.sv:207$314 ($lt): new $alu
  creating $alu cell for $lt$new_alu.sv:207$314: $auto$alumacc.cc:474:replace_alu$1140
  creating $alu cell for $ge$new_alu.sv:207$315: $auto$alumacc.cc:474:replace_alu$1147
  creating $alu cell for $ge$new_alu.sv:181$291: $auto$alumacc.cc:474:replace_alu$1162
  creating $alu cell for $add$new_alu.sv:199$297: $auto$alumacc.cc:474:replace_alu$1173
  creating $alu cell for $add$new_alu.sv:199$299: $auto$alumacc.cc:474:replace_alu$1176
  creating $alu cell for $add$new_alu.sv:199$301: $auto$alumacc.cc:474:replace_alu$1179
  creating $alu cell for $add$new_alu.sv:199$303: $auto$alumacc.cc:474:replace_alu$1182
  creating $alu cell for $add$new_alu.sv:199$305: $auto$alumacc.cc:474:replace_alu$1185
  creating $alu cell for $add$new_alu.sv:199$307: $auto$alumacc.cc:474:replace_alu$1188
  creating $alu cell for $add$new_alu.sv:199$309: $auto$alumacc.cc:474:replace_alu$1191
  creating $alu cell for $neg$new_alu.sv:187$292: $auto$alumacc.cc:474:replace_alu$1194
  created 11 $alu and 0 $macc cells.
Extracting $alu and $macc cells in module $paramod\add_bit\M=8\K=8:
  creating $macc model for $add$new_alu.sv:373$267 ($add).
  creating $macc model for $add$new_alu.sv:384$271 ($add).
  creating $alu model for $macc $add$new_alu.sv:384$271.
  creating $alu model for $macc $add$new_alu.sv:373$267.
  creating $alu model for $gt$new_alu.sv:373$268 ($gt): new $alu
  creating $alu model for $lt$new_alu.sv:377$270 ($lt): new $alu
  creating $alu cell for $lt$new_alu.sv:377$270: $auto$alumacc.cc:474:replace_alu$1199
  creating $alu cell for $gt$new_alu.sv:373$268: $auto$alumacc.cc:474:replace_alu$1212
  creating $alu cell for $add$new_alu.sv:373$267: $auto$alumacc.cc:474:replace_alu$1219
  creating $alu cell for $add$new_alu.sv:384$271: $auto$alumacc.cc:474:replace_alu$1222
  created 4 $alu and 0 $macc cells.
Extracting $alu and $macc cells in module $paramod\addition_1\M=8\K=8:
  creating $macc model for $add$new_alu.sv:30$211 ($add).
  creating $macc model for $add$new_alu.sv:62$228 ($add).
  creating $macc model for $sub$new_alu.sv:43$217 ($sub).
  creating $macc model for $sub$new_alu.sv:45$218 ($sub).
  creating $alu model for $macc $sub$new_alu.sv:45$218.
  creating $alu model for $macc $sub$new_alu.sv:43$217.
  creating $alu model for $macc $add$new_alu.sv:62$228.
  creating $alu model for $macc $add$new_alu.sv:30$211.
  creating $alu model for $gt$new_alu.sv:42$216 ($gt): merged with $sub$new_alu.sv:43$217.
  creating $alu cell for $add$new_alu.sv:30$211: $auto$alumacc.cc:474:replace_alu$1225
  creating $alu cell for $add$new_alu.sv:62$228: $auto$alumacc.cc:474:replace_alu$1228
  creating $alu cell for $sub$new_alu.sv:43$217, $gt$new_alu.sv:42$216: $auto$alumacc.cc:474:replace_alu$1231
  creating $alu cell for $sub$new_alu.sv:45$218: $auto$alumacc.cc:474:replace_alu$1242
  created 4 $alu and 0 $macc cells.
Extracting $alu and $macc cells in module $paramod\comparison_1\M=8\K=8:
  creating $alu model for $ge$new_alu.sv:231$319 ($ge): new $alu
  creating $alu cell for $ge$new_alu.sv:231$319: $auto$alumacc.cc:474:replace_alu$1246
  created 1 $alu and 0 $macc cells.
Extracting $alu and $macc cells in module $paramod\comparison_2\M=8\K=8:
  creating $alu model for $gt$new_alu.sv:455$265 ($gt): new $alu
  creating $alu model for $lt$new_alu.sv:435$261 ($lt): new $alu
  creating $alu model for $eq$new_alu.sv:427$256 ($eq): merged with $lt$new_alu.sv:435$261.
  creating $alu cell for $lt$new_alu.sv:435$261, $eq$new_alu.sv:427$256: $auto$alumacc.cc:474:replace_alu$1259
  creating $alu cell for $gt$new_alu.sv:455$265: $auto$alumacc.cc:474:replace_alu$1270
  created 2 $alu and 0 $macc cells.
Extracting $alu and $macc cells in module $paramod\division\M=8\K=8:
  creating $macc model for $add$new_alu.sv:284$353 ($add).
  creating $macc model for $add$new_alu.sv:284$355 ($add).
  creating $macc model for $add$new_alu.sv:284$357 ($add).
  creating $macc model for $add$new_alu.sv:284$359 ($add).
  creating $macc model for $add$new_alu.sv:284$361 ($add).
  creating $macc model for $add$new_alu.sv:284$363 ($add).
  creating $macc model for $add$new_alu.sv:284$365 ($add).
  creating $alu model for $macc $add$new_alu.sv:284$365.
  creating $alu model for $macc $add$new_alu.sv:284$363.
  creating $alu model for $macc $add$new_alu.sv:284$361.
  creating $alu model for $macc $add$new_alu.sv:284$359.
  creating $alu model for $macc $add$new_alu.sv:284$357.
  creating $alu model for $macc $add$new_alu.sv:284$355.
  creating $alu model for $macc $add$new_alu.sv:284$353.
  creating $alu model for $le$new_alu.sv:266$348 ($le): new $alu
  creating $alu cell for $le$new_alu.sv:266$348: $auto$alumacc.cc:474:replace_alu$1276
  creating $alu cell for $add$new_alu.sv:284$353: $auto$alumacc.cc:474:replace_alu$1291
  creating $alu cell for $add$new_alu.sv:284$355: $auto$alumacc.cc:474:replace_alu$1294
  creating $alu cell for $add$new_alu.sv:284$357: $auto$alumacc.cc:474:replace_alu$1297
  creating $alu cell for $add$new_alu.sv:284$359: $auto$alumacc.cc:474:replace_alu$1300
  creating $alu cell for $add$new_alu.sv:284$361: $auto$alumacc.cc:474:replace_alu$1303
  creating $alu cell for $add$new_alu.sv:284$363: $auto$alumacc.cc:474:replace_alu$1306
  creating $alu cell for $add$new_alu.sv:284$365: $auto$alumacc.cc:474:replace_alu$1309
  created 8 $alu and 0 $macc cells.
Extracting $alu and $macc cells in module $paramod\division_1\M=8\K=8:
  created 0 $alu and 0 $macc cells.
Extracting $alu and $macc cells in module $paramod\right_shift_1\M=8\K=8:
  created 0 $alu and 0 $macc cells.
Extracting $alu and $macc cells in module $paramod\right_shift_2\M=8\K=8:
  creating $macc model for $add$new_alu.sv:338$387 ($add).
  creating $macc model for $add$new_alu.sv:338$389 ($add).
  creating $macc model for $add$new_alu.sv:338$391 ($add).
  creating $macc model for $add$new_alu.sv:338$393 ($add).
  creating $macc model for $add$new_alu.sv:338$395 ($add).
  creating $macc model for $add$new_alu.sv:338$397 ($add).
  creating $macc model for $add$new_alu.sv:338$399 ($add).
  creating $alu model for $macc $add$new_alu.sv:338$399.
  creating $alu model for $macc $add$new_alu.sv:338$397.
  creating $alu model for $macc $add$new_alu.sv:338$395.
  creating $alu model for $macc $add$new_alu.sv:338$393.
  creating $alu model for $macc $add$new_alu.sv:338$391.
  creating $alu model for $macc $add$new_alu.sv:338$389.
  creating $alu model for $macc $add$new_alu.sv:338$387.
  creating $alu model for $ge$new_alu.sv:314$379 ($ge): new $alu
  creating $alu model for $le$new_alu.sv:320$382 ($le): new $alu
  creating $alu cell for $le$new_alu.sv:320$382: $auto$alumacc.cc:474:replace_alu$1314
  creating $alu cell for $ge$new_alu.sv:314$379: $auto$alumacc.cc:474:replace_alu$1327
  creating $alu cell for $add$new_alu.sv:338$387: $auto$alumacc.cc:474:replace_alu$1338
  creating $alu cell for $add$new_alu.sv:338$389: $auto$alumacc.cc:474:replace_alu$1341
  creating $alu cell for $add$new_alu.sv:338$391: $auto$alumacc.cc:474:replace_alu$1344
  creating $alu cell for $add$new_alu.sv:338$393: $auto$alumacc.cc:474:replace_alu$1347
  creating $alu cell for $add$new_alu.sv:338$395: $auto$alumacc.cc:474:replace_alu$1350
  creating $alu cell for $add$new_alu.sv:338$397: $auto$alumacc.cc:474:replace_alu$1353
  creating $alu cell for $add$new_alu.sv:338$399: $auto$alumacc.cc:474:replace_alu$1356
  created 9 $alu and 0 $macc cells.
Extracting $alu and $macc cells in module $paramod\sub_and_mul\M=8\K=8:
  creating $macc model for $sub$new_alu.sv:501$244 ($sub).
  creating $macc model for $sub$new_alu.sv:519$248 ($sub).
  creating $alu model for $macc $sub$new_alu.sv:519$248.
  creating $alu model for $macc $sub$new_alu.sv:501$244.
  creating $alu model for $gt$new_alu.sv:501$245 ($gt): new $alu
  creating $alu model for $lt$new_alu.sv:508$247 ($lt): new $alu
  creating $alu cell for $lt$new_alu.sv:508$247: $auto$alumacc.cc:474:replace_alu$1361
  creating $alu cell for $gt$new_alu.sv:501$245: $auto$alumacc.cc:474:replace_alu$1374
  creating $alu cell for $sub$new_alu.sv:501$244: $auto$alumacc.cc:474:replace_alu$1381
  creating $alu cell for $sub$new_alu.sv:519$248: $auto$alumacc.cc:474:replace_alu$1384
  created 4 $alu and 0 $macc cells.
Extracting $alu and $macc cells in module $paramod\u2_to_zm\M=8\K=8:
  creating $macc model for $add$new_alu.sv:553$281 ($add).
  creating $alu model for $macc $add$new_alu.sv:553$281.
  creating $alu cell for $add$new_alu.sv:553$281: $auto$alumacc.cc:474:replace_alu$1387
  created 1 $alu and 0 $macc cells.
Extracting $alu and $macc cells in module $paramod\zm_to_u2\M=8\K=8:
  creating $macc model for $add$new_alu.sv:156$241 ($add).
  creating $alu model for $macc $add$new_alu.sv:156$241.
  creating $alu cell for $add$new_alu.sv:156$241: $auto$alumacc.cc:474:replace_alu$1390
  created 1 $alu and 0 $macc cells.
Extracting $alu and $macc cells in module synth_new_alu:
  created 0 $alu and 0 $macc cells.

3.12. Executing SHARE pass (SAT-based resource sharing).

3.13. Executing OPT pass (performing simple optimizations).

3.13.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module $paramod\absolute\M=8\K=8.
Optimizing module $paramod\add_bit\M=8\K=8.
<suppressed ~1 debug messages>
Optimizing module $paramod\addition_1\M=8\K=8.
<suppressed ~2 debug messages>
Optimizing module $paramod\comparison_1\M=8\K=8.
Optimizing module $paramod\comparison_2\M=8\K=8.
<suppressed ~2 debug messages>
Optimizing module $paramod\division\M=8\K=8.
Optimizing module $paramod\division_1\M=8\K=8.
Optimizing module $paramod\right_shift_1\M=8\K=8.
Optimizing module $paramod\right_shift_2\M=8\K=8.
Optimizing module $paramod\sub_and_mul\M=8\K=8.
<suppressed ~1 debug messages>
Optimizing module $paramod\u2_to_zm\M=8\K=8.
Optimizing module $paramod\zm_to_u2\M=8\K=8.
Optimizing module synth_new_alu.

3.13.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `$paramod\absolute\M=8\K=8'.
Finding identical cells in module `$paramod\add_bit\M=8\K=8'.
Finding identical cells in module `$paramod\addition_1\M=8\K=8'.
Finding identical cells in module `$paramod\comparison_1\M=8\K=8'.
Finding identical cells in module `$paramod\comparison_2\M=8\K=8'.
Finding identical cells in module `$paramod\division\M=8\K=8'.
Finding identical cells in module `$paramod\division_1\M=8\K=8'.
Finding identical cells in module `$paramod\right_shift_1\M=8\K=8'.
Finding identical cells in module `$paramod\right_shift_2\M=8\K=8'.
Finding identical cells in module `$paramod\sub_and_mul\M=8\K=8'.
Finding identical cells in module `$paramod\u2_to_zm\M=8\K=8'.
Finding identical cells in module `$paramod\zm_to_u2\M=8\K=8'.
Finding identical cells in module `\synth_new_alu'.
Removed a total of 0 cells.

3.13.3. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module $paramod\absolute\M=8\K=8..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module $paramod\add_bit\M=8\K=8..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module $paramod\addition_1\M=8\K=8..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module $paramod\comparison_1\M=8\K=8..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module $paramod\comparison_2\M=8\K=8..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module $paramod\division\M=8\K=8..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module $paramod\division_1\M=8\K=8..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module $paramod\right_shift_1\M=8\K=8..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module $paramod\right_shift_2\M=8\K=8..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module $paramod\sub_and_mul\M=8\K=8..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module $paramod\u2_to_zm\M=8\K=8..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module $paramod\zm_to_u2\M=8\K=8..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \synth_new_alu..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Removed 0 multiplexer ports.
<suppressed ~57 debug messages>

3.13.4. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
  Optimizing cells in module $paramod\absolute\M=8\K=8.
    New input vector for $reduce_and cell $auto$alumacc.cc:64:get_eq$1150: { $auto$alumacc.cc:490:replace_alu$1148 [0] $auto$alumacc.cc:490:replace_alu$1148 [1] $auto$alumacc.cc:490:replace_alu$1148 [2] $auto$alumacc.cc:490:replace_alu$1148 [3] $auto$alumacc.cc:490:replace_alu$1148 [4] $auto$alumacc.cc:490:replace_alu$1148 [5] $auto$alumacc.cc:490:replace_alu$1148 [6] $auto$alumacc.cc:490:replace_alu$1148 [7] $auto$alumacc.cc:490:replace_alu$1148 [8] }
    New input vector for $reduce_and cell $auto$alumacc.cc:64:get_eq$1169: { $auto$alumacc.cc:490:replace_alu$1163 [0] $auto$alumacc.cc:490:replace_alu$1163 [1] $auto$alumacc.cc:490:replace_alu$1163 [2] $auto$alumacc.cc:490:replace_alu$1163 [3] $auto$alumacc.cc:490:replace_alu$1163 [4] $auto$alumacc.cc:490:replace_alu$1163 [5] $auto$alumacc.cc:490:replace_alu$1163 [6] $auto$alumacc.cc:490:replace_alu$1163 [7] }
  Optimizing cells in module $paramod\absolute\M=8\K=8.
  Optimizing cells in module $paramod\add_bit\M=8\K=8.
    New input vector for $reduce_and cell $auto$alumacc.cc:64:get_eq$1202: { $auto$alumacc.cc:490:replace_alu$1200 [0] $auto$alumacc.cc:490:replace_alu$1200 [1] $auto$alumacc.cc:490:replace_alu$1200 [2] $auto$alumacc.cc:490:replace_alu$1200 [3] $auto$alumacc.cc:490:replace_alu$1200 [4] $auto$alumacc.cc:490:replace_alu$1200 [5] $auto$alumacc.cc:490:replace_alu$1200 [6] $auto$alumacc.cc:490:replace_alu$1200 [7] $auto$alumacc.cc:490:replace_alu$1200 [8] $auto$alumacc.cc:490:replace_alu$1200 [9] $auto$alumacc.cc:490:replace_alu$1200 [10] $auto$alumacc.cc:490:replace_alu$1200 [11] $auto$alumacc.cc:490:replace_alu$1200 [12] $auto$alumacc.cc:490:replace_alu$1200 [13] $auto$alumacc.cc:490:replace_alu$1200 [14] $auto$alumacc.cc:490:replace_alu$1200 [15] $auto$alumacc.cc:490:replace_alu$1200 [16] $auto$alumacc.cc:490:replace_alu$1200 [17] $auto$alumacc.cc:490:replace_alu$1200 [18] $auto$alumacc.cc:490:replace_alu$1200 [19] $auto$alumacc.cc:490:replace_alu$1200 [20] $auto$alumacc.cc:490:replace_alu$1200 [21] $auto$alumacc.cc:490:replace_alu$1200 [22] $auto$alumacc.cc:490:replace_alu$1200 [23] $auto$alumacc.cc:490:replace_alu$1200 [24] $auto$alumacc.cc:490:replace_alu$1200 [25] $auto$alumacc.cc:490:replace_alu$1200 [26] $auto$alumacc.cc:490:replace_alu$1200 [27] $auto$alumacc.cc:490:replace_alu$1200 [28] $auto$alumacc.cc:490:replace_alu$1200 [29] $auto$alumacc.cc:490:replace_alu$1200 [30] $auto$alumacc.cc:490:replace_alu$1200 [31] }
  Optimizing cells in module $paramod\add_bit\M=8\K=8.
  Optimizing cells in module $paramod\addition_1\M=8\K=8.
    New input vector for $reduce_and cell $auto$alumacc.cc:64:get_eq$1234: { $auto$alumacc.cc:490:replace_alu$1232 [0] $auto$alumacc.cc:490:replace_alu$1232 [1] $auto$alumacc.cc:490:replace_alu$1232 [2] $auto$alumacc.cc:490:replace_alu$1232 [3] $auto$alumacc.cc:490:replace_alu$1232 [4] $auto$alumacc.cc:490:replace_alu$1232 [5] $auto$alumacc.cc:490:replace_alu$1232 [6] }
  Optimizing cells in module $paramod\addition_1\M=8\K=8.
  Optimizing cells in module $paramod\comparison_1\M=8\K=8.
    New input vector for $reduce_and cell $auto$alumacc.cc:64:get_eq$1253: { $auto$alumacc.cc:490:replace_alu$1247 [0] $auto$alumacc.cc:490:replace_alu$1247 [1] $auto$alumacc.cc:490:replace_alu$1247 [2] $auto$alumacc.cc:490:replace_alu$1247 [3] $auto$alumacc.cc:490:replace_alu$1247 [4] $auto$alumacc.cc:490:replace_alu$1247 [5] $auto$alumacc.cc:490:replace_alu$1247 [6] $auto$alumacc.cc:490:replace_alu$1247 [7] }
  Optimizing cells in module $paramod\comparison_1\M=8\K=8.
  Optimizing cells in module $paramod\comparison_2\M=8\K=8.
    New input vector for $reduce_and cell $auto$alumacc.cc:64:get_eq$1262: { $auto$alumacc.cc:490:replace_alu$1260 [0] $auto$alumacc.cc:490:replace_alu$1260 [1] $auto$alumacc.cc:490:replace_alu$1260 [2] $auto$alumacc.cc:490:replace_alu$1260 [3] $auto$alumacc.cc:490:replace_alu$1260 [4] $auto$alumacc.cc:490:replace_alu$1260 [5] $auto$alumacc.cc:490:replace_alu$1260 [6] $auto$alumacc.cc:490:replace_alu$1260 [7] }
  Optimizing cells in module $paramod\comparison_2\M=8\K=8.
  Optimizing cells in module $paramod\division\M=8\K=8.
    New input vector for $reduce_or cell $auto$alumacc.cc:509:replace_alu$1289: { $auto$rtlil.cc:1832:Not$1288 $auto$rtlil.cc:1835:ReduceAnd$1280 }
    New input vector for $reduce_and cell $auto$alumacc.cc:64:get_eq$1279: { $auto$alumacc.cc:490:replace_alu$1277 [0] $auto$alumacc.cc:490:replace_alu$1277 [1] $auto$alumacc.cc:490:replace_alu$1277 [2] $auto$alumacc.cc:490:replace_alu$1277 [3] $auto$alumacc.cc:490:replace_alu$1277 [4] $auto$alumacc.cc:490:replace_alu$1277 [5] $auto$alumacc.cc:490:replace_alu$1277 [6] $auto$alumacc.cc:490:replace_alu$1277 [7] }
  Optimizing cells in module $paramod\division\M=8\K=8.
  Optimizing cells in module $paramod\division_1\M=8\K=8.
  Optimizing cells in module $paramod\right_shift_1\M=8\K=8.
  Optimizing cells in module $paramod\right_shift_2\M=8\K=8.
    New input vector for $reduce_or cell $auto$alumacc.cc:509:replace_alu$1325: { $auto$rtlil.cc:1832:Not$1324 $auto$rtlil.cc:1835:ReduceAnd$1318 }
    New input vector for $reduce_or cell $auto$alumacc.cc:509:replace_alu$1336: { $auto$rtlil.cc:1864:Xor$1333 $auto$rtlil.cc:1835:ReduceAnd$1335 }
    New input vector for $reduce_and cell $auto$alumacc.cc:64:get_eq$1317: { $auto$alumacc.cc:490:replace_alu$1315 [0] $auto$alumacc.cc:490:replace_alu$1315 [1] $auto$alumacc.cc:490:replace_alu$1315 [2] $auto$alumacc.cc:490:replace_alu$1315 [3] $auto$alumacc.cc:490:replace_alu$1315 [4] $auto$alumacc.cc:490:replace_alu$1315 [5] $auto$alumacc.cc:490:replace_alu$1315 [6] $auto$alumacc.cc:490:replace_alu$1315 [7] }
    New input vector for $reduce_and cell $auto$alumacc.cc:64:get_eq$1334: { $auto$alumacc.cc:490:replace_alu$1328 [0] $auto$alumacc.cc:490:replace_alu$1328 [1] $auto$alumacc.cc:490:replace_alu$1328 [2] $auto$alumacc.cc:490:replace_alu$1328 [3] $auto$alumacc.cc:490:replace_alu$1328 [4] $auto$alumacc.cc:490:replace_alu$1328 [5] $auto$alumacc.cc:490:replace_alu$1328 [6] $auto$alumacc.cc:490:replace_alu$1328 [7] }
  Optimizing cells in module $paramod\right_shift_2\M=8\K=8.
  Optimizing cells in module $paramod\sub_and_mul\M=8\K=8.
    New input vector for $reduce_and cell $auto$alumacc.cc:64:get_eq$1364: { $auto$alumacc.cc:490:replace_alu$1362 [0] $auto$alumacc.cc:490:replace_alu$1362 [1] $auto$alumacc.cc:490:replace_alu$1362 [2] $auto$alumacc.cc:490:replace_alu$1362 [3] $auto$alumacc.cc:490:replace_alu$1362 [4] $auto$alumacc.cc:490:replace_alu$1362 [5] $auto$alumacc.cc:490:replace_alu$1362 [6] $auto$alumacc.cc:490:replace_alu$1362 [7] $auto$alumacc.cc:490:replace_alu$1362 [8] $auto$alumacc.cc:490:replace_alu$1362 [9] $auto$alumacc.cc:490:replace_alu$1362 [10] $auto$alumacc.cc:490:replace_alu$1362 [11] $auto$alumacc.cc:490:replace_alu$1362 [12] $auto$alumacc.cc:490:replace_alu$1362 [13] $auto$alumacc.cc:490:replace_alu$1362 [14] $auto$alumacc.cc:490:replace_alu$1362 [15] $auto$alumacc.cc:490:replace_alu$1362 [16] $auto$alumacc.cc:490:replace_alu$1362 [17] $auto$alumacc.cc:490:replace_alu$1362 [18] $auto$alumacc.cc:490:replace_alu$1362 [19] $auto$alumacc.cc:490:replace_alu$1362 [20] $auto$alumacc.cc:490:replace_alu$1362 [21] $auto$alumacc.cc:490:replace_alu$1362 [22] $auto$alumacc.cc:490:replace_alu$1362 [23] $auto$alumacc.cc:490:replace_alu$1362 [24] $auto$alumacc.cc:490:replace_alu$1362 [25] $auto$alumacc.cc:490:replace_alu$1362 [26] $auto$alumacc.cc:490:replace_alu$1362 [27] $auto$alumacc.cc:490:replace_alu$1362 [28] $auto$alumacc.cc:490:replace_alu$1362 [29] $auto$alumacc.cc:490:replace_alu$1362 [30] $auto$alumacc.cc:490:replace_alu$1362 [31] }
  Optimizing cells in module $paramod\sub_and_mul\M=8\K=8.
  Optimizing cells in module $paramod\u2_to_zm\M=8\K=8.
  Optimizing cells in module $paramod\zm_to_u2\M=8\K=8.
  Optimizing cells in module \synth_new_alu.
Performed a total of 13 changes.

3.13.5. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `$paramod\absolute\M=8\K=8'.
Finding identical cells in module `$paramod\add_bit\M=8\K=8'.
Finding identical cells in module `$paramod\addition_1\M=8\K=8'.
Finding identical cells in module `$paramod\comparison_1\M=8\K=8'.
Finding identical cells in module `$paramod\comparison_2\M=8\K=8'.
Finding identical cells in module `$paramod\division\M=8\K=8'.
Finding identical cells in module `$paramod\division_1\M=8\K=8'.
Finding identical cells in module `$paramod\right_shift_1\M=8\K=8'.
Finding identical cells in module `$paramod\right_shift_2\M=8\K=8'.
Finding identical cells in module `$paramod\sub_and_mul\M=8\K=8'.
Finding identical cells in module `$paramod\u2_to_zm\M=8\K=8'.
Finding identical cells in module `$paramod\zm_to_u2\M=8\K=8'.
Finding identical cells in module `\synth_new_alu'.
Removed a total of 0 cells.

3.13.6. Executing OPT_RMDFF pass (remove dff with constant values).

3.13.7. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module $paramod\absolute\M=8\K=8..
Finding unused cells or wires in module $paramod\add_bit\M=8\K=8..
Finding unused cells or wires in module $paramod\addition_1\M=8\K=8..
Finding unused cells or wires in module $paramod\comparison_1\M=8\K=8..
Finding unused cells or wires in module $paramod\comparison_2\M=8\K=8..
Finding unused cells or wires in module $paramod\division\M=8\K=8..
Finding unused cells or wires in module $paramod\division_1\M=8\K=8..
Finding unused cells or wires in module $paramod\right_shift_1\M=8\K=8..
Finding unused cells or wires in module $paramod\right_shift_2\M=8\K=8..
Finding unused cells or wires in module $paramod\sub_and_mul\M=8\K=8..
Finding unused cells or wires in module $paramod\u2_to_zm\M=8\K=8..
Finding unused cells or wires in module $paramod\zm_to_u2\M=8\K=8..
Finding unused cells or wires in module \synth_new_alu..
Removed 5 unused cells and 20 unused wires.
<suppressed ~13 debug messages>

3.13.8. Executing OPT_EXPR pass (perform const folding).
Optimizing module $paramod\absolute\M=8\K=8.
Optimizing module $paramod\add_bit\M=8\K=8.
Optimizing module $paramod\addition_1\M=8\K=8.
Optimizing module $paramod\comparison_1\M=8\K=8.
Optimizing module $paramod\comparison_2\M=8\K=8.
Optimizing module $paramod\division\M=8\K=8.
Optimizing module $paramod\division_1\M=8\K=8.
Optimizing module $paramod\right_shift_1\M=8\K=8.
Optimizing module $paramod\right_shift_2\M=8\K=8.
Optimizing module $paramod\sub_and_mul\M=8\K=8.
Optimizing module $paramod\u2_to_zm\M=8\K=8.
Optimizing module $paramod\zm_to_u2\M=8\K=8.
Optimizing module synth_new_alu.

3.13.9. Rerunning OPT passes. (Maybe there is more to do..)

3.13.10. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module $paramod\absolute\M=8\K=8..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module $paramod\add_bit\M=8\K=8..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module $paramod\addition_1\M=8\K=8..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module $paramod\comparison_1\M=8\K=8..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module $paramod\comparison_2\M=8\K=8..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module $paramod\division\M=8\K=8..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module $paramod\division_1\M=8\K=8..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module $paramod\right_shift_1\M=8\K=8..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module $paramod\right_shift_2\M=8\K=8..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module $paramod\sub_and_mul\M=8\K=8..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module $paramod\u2_to_zm\M=8\K=8..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module $paramod\zm_to_u2\M=8\K=8..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \synth_new_alu..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Removed 0 multiplexer ports.
<suppressed ~57 debug messages>

3.13.11. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
  Optimizing cells in module $paramod\absolute\M=8\K=8.
  Optimizing cells in module $paramod\add_bit\M=8\K=8.
  Optimizing cells in module $paramod\addition_1\M=8\K=8.
  Optimizing cells in module $paramod\comparison_1\M=8\K=8.
  Optimizing cells in module $paramod\comparison_2\M=8\K=8.
  Optimizing cells in module $paramod\division\M=8\K=8.
  Optimizing cells in module $paramod\division_1\M=8\K=8.
  Optimizing cells in module $paramod\right_shift_1\M=8\K=8.
  Optimizing cells in module $paramod\right_shift_2\M=8\K=8.
  Optimizing cells in module $paramod\sub_and_mul\M=8\K=8.
  Optimizing cells in module $paramod\u2_to_zm\M=8\K=8.
  Optimizing cells in module $paramod\zm_to_u2\M=8\K=8.
  Optimizing cells in module \synth_new_alu.
Performed a total of 0 changes.

3.13.12. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `$paramod\absolute\M=8\K=8'.
Finding identical cells in module `$paramod\add_bit\M=8\K=8'.
Finding identical cells in module `$paramod\addition_1\M=8\K=8'.
Finding identical cells in module `$paramod\comparison_1\M=8\K=8'.
Finding identical cells in module `$paramod\comparison_2\M=8\K=8'.
Finding identical cells in module `$paramod\division\M=8\K=8'.
Finding identical cells in module `$paramod\division_1\M=8\K=8'.
Finding identical cells in module `$paramod\right_shift_1\M=8\K=8'.
Finding identical cells in module `$paramod\right_shift_2\M=8\K=8'.
Finding identical cells in module `$paramod\sub_and_mul\M=8\K=8'.
Finding identical cells in module `$paramod\u2_to_zm\M=8\K=8'.
Finding identical cells in module `$paramod\zm_to_u2\M=8\K=8'.
Finding identical cells in module `\synth_new_alu'.
Removed a total of 0 cells.

3.13.13. Executing OPT_RMDFF pass (remove dff with constant values).

3.13.14. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module $paramod\absolute\M=8\K=8..
Finding unused cells or wires in module $paramod\add_bit\M=8\K=8..
Finding unused cells or wires in module $paramod\addition_1\M=8\K=8..
Finding unused cells or wires in module $paramod\comparison_1\M=8\K=8..
Finding unused cells or wires in module $paramod\comparison_2\M=8\K=8..
Finding unused cells or wires in module $paramod\division\M=8\K=8..
Finding unused cells or wires in module $paramod\division_1\M=8\K=8..
Finding unused cells or wires in module $paramod\right_shift_1\M=8\K=8..
Finding unused cells or wires in module $paramod\right_shift_2\M=8\K=8..
Finding unused cells or wires in module $paramod\sub_and_mul\M=8\K=8..
Finding unused cells or wires in module $paramod\u2_to_zm\M=8\K=8..
Finding unused cells or wires in module $paramod\zm_to_u2\M=8\K=8..
Finding unused cells or wires in module \synth_new_alu..

3.13.15. Executing OPT_EXPR pass (perform const folding).
Optimizing module $paramod\absolute\M=8\K=8.
Optimizing module $paramod\add_bit\M=8\K=8.
Optimizing module $paramod\addition_1\M=8\K=8.
Optimizing module $paramod\comparison_1\M=8\K=8.
Optimizing module $paramod\comparison_2\M=8\K=8.
Optimizing module $paramod\division\M=8\K=8.
Optimizing module $paramod\division_1\M=8\K=8.
Optimizing module $paramod\right_shift_1\M=8\K=8.
Optimizing module $paramod\right_shift_2\M=8\K=8.
Optimizing module $paramod\sub_and_mul\M=8\K=8.
Optimizing module $paramod\u2_to_zm\M=8\K=8.
Optimizing module $paramod\zm_to_u2\M=8\K=8.
Optimizing module synth_new_alu.

3.13.16. Finished OPT passes. (There is nothing left to do.)

3.14. Executing FSM pass (extract and optimize FSM).

3.14.1. Executing FSM_DETECT pass (finding FSMs in design).

3.14.2. Executing FSM_EXTRACT pass (extracting FSM from design).

3.14.3. Executing FSM_OPT pass (simple optimizations of FSMs).

3.14.4. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module $paramod\absolute\M=8\K=8..
Finding unused cells or wires in module $paramod\add_bit\M=8\K=8..
Finding unused cells or wires in module $paramod\addition_1\M=8\K=8..
Finding unused cells or wires in module $paramod\comparison_1\M=8\K=8..
Finding unused cells or wires in module $paramod\comparison_2\M=8\K=8..
Finding unused cells or wires in module $paramod\division\M=8\K=8..
Finding unused cells or wires in module $paramod\division_1\M=8\K=8..
Finding unused cells or wires in module $paramod\right_shift_1\M=8\K=8..
Finding unused cells or wires in module $paramod\right_shift_2\M=8\K=8..
Finding unused cells or wires in module $paramod\sub_and_mul\M=8\K=8..
Finding unused cells or wires in module $paramod\u2_to_zm\M=8\K=8..
Finding unused cells or wires in module $paramod\zm_to_u2\M=8\K=8..
Finding unused cells or wires in module \synth_new_alu..

3.14.5. Executing FSM_OPT pass (simple optimizations of FSMs).

3.14.6. Executing FSM_RECODE pass (re-assigning FSM state encoding).

3.14.7. Executing FSM_INFO pass (dumping all available information on FSM cells).

3.14.8. Executing FSM_MAP pass (mapping FSMs to basic logic).

3.15. Executing OPT pass (performing simple optimizations).

3.15.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module $paramod\absolute\M=8\K=8.
Optimizing module $paramod\add_bit\M=8\K=8.
Optimizing module $paramod\addition_1\M=8\K=8.
Optimizing module $paramod\comparison_1\M=8\K=8.
Optimizing module $paramod\comparison_2\M=8\K=8.
Optimizing module $paramod\division\M=8\K=8.
Optimizing module $paramod\division_1\M=8\K=8.
Optimizing module $paramod\right_shift_1\M=8\K=8.
Optimizing module $paramod\right_shift_2\M=8\K=8.
Optimizing module $paramod\sub_and_mul\M=8\K=8.
Optimizing module $paramod\u2_to_zm\M=8\K=8.
Optimizing module $paramod\zm_to_u2\M=8\K=8.
Optimizing module synth_new_alu.

3.15.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `$paramod\absolute\M=8\K=8'.
Finding identical cells in module `$paramod\add_bit\M=8\K=8'.
Finding identical cells in module `$paramod\addition_1\M=8\K=8'.
Finding identical cells in module `$paramod\comparison_1\M=8\K=8'.
Finding identical cells in module `$paramod\comparison_2\M=8\K=8'.
Finding identical cells in module `$paramod\division\M=8\K=8'.
Finding identical cells in module `$paramod\division_1\M=8\K=8'.
Finding identical cells in module `$paramod\right_shift_1\M=8\K=8'.
Finding identical cells in module `$paramod\right_shift_2\M=8\K=8'.
Finding identical cells in module `$paramod\sub_and_mul\M=8\K=8'.
Finding identical cells in module `$paramod\u2_to_zm\M=8\K=8'.
Finding identical cells in module `$paramod\zm_to_u2\M=8\K=8'.
Finding identical cells in module `\synth_new_alu'.
Removed a total of 0 cells.

3.15.3. Executing OPT_RMDFF pass (remove dff with constant values).

3.15.4. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module $paramod\absolute\M=8\K=8..
Finding unused cells or wires in module $paramod\add_bit\M=8\K=8..
Finding unused cells or wires in module $paramod\addition_1\M=8\K=8..
Finding unused cells or wires in module $paramod\comparison_1\M=8\K=8..
Finding unused cells or wires in module $paramod\comparison_2\M=8\K=8..
Finding unused cells or wires in module $paramod\division\M=8\K=8..
Finding unused cells or wires in module $paramod\division_1\M=8\K=8..
Finding unused cells or wires in module $paramod\right_shift_1\M=8\K=8..
Finding unused cells or wires in module $paramod\right_shift_2\M=8\K=8..
Finding unused cells or wires in module $paramod\sub_and_mul\M=8\K=8..
Finding unused cells or wires in module $paramod\u2_to_zm\M=8\K=8..
Finding unused cells or wires in module $paramod\zm_to_u2\M=8\K=8..
Finding unused cells or wires in module \synth_new_alu..

3.15.5. Finished fast OPT passes.

3.16. Executing MEMORY pass.

3.16.1. Executing MEMORY_DFF pass (merging $dff cells to $memrd and $memwr).

3.16.2. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module $paramod\absolute\M=8\K=8..
Finding unused cells or wires in module $paramod\add_bit\M=8\K=8..
Finding unused cells or wires in module $paramod\addition_1\M=8\K=8..
Finding unused cells or wires in module $paramod\comparison_1\M=8\K=8..
Finding unused cells or wires in module $paramod\comparison_2\M=8\K=8..
Finding unused cells or wires in module $paramod\division\M=8\K=8..
Finding unused cells or wires in module $paramod\division_1\M=8\K=8..
Finding unused cells or wires in module $paramod\right_shift_1\M=8\K=8..
Finding unused cells or wires in module $paramod\right_shift_2\M=8\K=8..
Finding unused cells or wires in module $paramod\sub_and_mul\M=8\K=8..
Finding unused cells or wires in module $paramod\u2_to_zm\M=8\K=8..
Finding unused cells or wires in module $paramod\zm_to_u2\M=8\K=8..
Finding unused cells or wires in module \synth_new_alu..

3.16.3. Executing MEMORY_SHARE pass (consolidating $memrd/$memwr cells).

3.16.4. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module $paramod\absolute\M=8\K=8..
Finding unused cells or wires in module $paramod\add_bit\M=8\K=8..
Finding unused cells or wires in module $paramod\addition_1\M=8\K=8..
Finding unused cells or wires in module $paramod\comparison_1\M=8\K=8..
Finding unused cells or wires in module $paramod\comparison_2\M=8\K=8..
Finding unused cells or wires in module $paramod\division\M=8\K=8..
Finding unused cells or wires in module $paramod\division_1\M=8\K=8..
Finding unused cells or wires in module $paramod\right_shift_1\M=8\K=8..
Finding unused cells or wires in module $paramod\right_shift_2\M=8\K=8..
Finding unused cells or wires in module $paramod\sub_and_mul\M=8\K=8..
Finding unused cells or wires in module $paramod\u2_to_zm\M=8\K=8..
Finding unused cells or wires in module $paramod\zm_to_u2\M=8\K=8..
Finding unused cells or wires in module \synth_new_alu..

3.16.5. Executing MEMORY_COLLECT pass (generating $mem cells).

3.17. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module $paramod\absolute\M=8\K=8..
Finding unused cells or wires in module $paramod\add_bit\M=8\K=8..
Finding unused cells or wires in module $paramod\addition_1\M=8\K=8..
Finding unused cells or wires in module $paramod\comparison_1\M=8\K=8..
Finding unused cells or wires in module $paramod\comparison_2\M=8\K=8..
Finding unused cells or wires in module $paramod\division\M=8\K=8..
Finding unused cells or wires in module $paramod\division_1\M=8\K=8..
Finding unused cells or wires in module $paramod\right_shift_1\M=8\K=8..
Finding unused cells or wires in module $paramod\right_shift_2\M=8\K=8..
Finding unused cells or wires in module $paramod\sub_and_mul\M=8\K=8..
Finding unused cells or wires in module $paramod\u2_to_zm\M=8\K=8..
Finding unused cells or wires in module $paramod\zm_to_u2\M=8\K=8..
Finding unused cells or wires in module \synth_new_alu..

3.18. Executing OPT pass (performing simple optimizations).

3.18.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module $paramod\absolute\M=8\K=8.
<suppressed ~11 debug messages>
Optimizing module $paramod\add_bit\M=8\K=8.
Optimizing module $paramod\addition_1\M=8\K=8.
Optimizing module $paramod\comparison_1\M=8\K=8.
<suppressed ~3 debug messages>
Optimizing module $paramod\comparison_2\M=8\K=8.
<suppressed ~2 debug messages>
Optimizing module $paramod\division\M=8\K=8.
<suppressed ~13 debug messages>
Optimizing module $paramod\division_1\M=8\K=8.
Optimizing module $paramod\right_shift_1\M=8\K=8.
Optimizing module $paramod\right_shift_2\M=8\K=8.
<suppressed ~13 debug messages>
Optimizing module $paramod\sub_and_mul\M=8\K=8.
Optimizing module $paramod\u2_to_zm\M=8\K=8.
Optimizing module $paramod\zm_to_u2\M=8\K=8.
Optimizing module synth_new_alu.
<suppressed ~10 debug messages>

3.18.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `$paramod\absolute\M=8\K=8'.
Finding identical cells in module `$paramod\add_bit\M=8\K=8'.
Finding identical cells in module `$paramod\addition_1\M=8\K=8'.
Finding identical cells in module `$paramod\comparison_1\M=8\K=8'.
Finding identical cells in module `$paramod\comparison_2\M=8\K=8'.
Finding identical cells in module `$paramod\division\M=8\K=8'.
Finding identical cells in module `$paramod\division_1\M=8\K=8'.
Finding identical cells in module `$paramod\right_shift_1\M=8\K=8'.
Finding identical cells in module `$paramod\right_shift_2\M=8\K=8'.
Finding identical cells in module `$paramod\sub_and_mul\M=8\K=8'.
Finding identical cells in module `$paramod\u2_to_zm\M=8\K=8'.
Finding identical cells in module `$paramod\zm_to_u2\M=8\K=8'.
Finding identical cells in module `\synth_new_alu'.
Removed a total of 0 cells.

3.18.3. Executing OPT_RMDFF pass (remove dff with constant values).

3.18.4. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module $paramod\absolute\M=8\K=8..
Finding unused cells or wires in module $paramod\add_bit\M=8\K=8..
Finding unused cells or wires in module $paramod\addition_1\M=8\K=8..
Finding unused cells or wires in module $paramod\comparison_1\M=8\K=8..
Finding unused cells or wires in module $paramod\comparison_2\M=8\K=8..
Finding unused cells or wires in module $paramod\division\M=8\K=8..
Finding unused cells or wires in module $paramod\division_1\M=8\K=8..
Finding unused cells or wires in module $paramod\right_shift_1\M=8\K=8..
Finding unused cells or wires in module $paramod\right_shift_2\M=8\K=8..
Finding unused cells or wires in module $paramod\sub_and_mul\M=8\K=8..
Finding unused cells or wires in module $paramod\u2_to_zm\M=8\K=8..
Finding unused cells or wires in module $paramod\zm_to_u2\M=8\K=8..
Finding unused cells or wires in module \synth_new_alu..
Removed 1 unused cells and 22 unused wires.
<suppressed ~6 debug messages>

3.18.5. Finished fast OPT passes.

3.19. Executing MEMORY_MAP pass (converting $mem cells to logic and flip-flops).

3.20. Executing OPT pass (performing simple optimizations).

3.20.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module $paramod\absolute\M=8\K=8.
Optimizing module $paramod\add_bit\M=8\K=8.
Optimizing module $paramod\addition_1\M=8\K=8.
Optimizing module $paramod\comparison_1\M=8\K=8.
Optimizing module $paramod\comparison_2\M=8\K=8.
Optimizing module $paramod\division\M=8\K=8.
Optimizing module $paramod\division_1\M=8\K=8.
Optimizing module $paramod\right_shift_1\M=8\K=8.
Optimizing module $paramod\right_shift_2\M=8\K=8.
Optimizing module $paramod\sub_and_mul\M=8\K=8.
Optimizing module $paramod\u2_to_zm\M=8\K=8.
Optimizing module $paramod\zm_to_u2\M=8\K=8.
Optimizing module synth_new_alu.

3.20.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `$paramod\absolute\M=8\K=8'.
Finding identical cells in module `$paramod\add_bit\M=8\K=8'.
Finding identical cells in module `$paramod\addition_1\M=8\K=8'.
Finding identical cells in module `$paramod\comparison_1\M=8\K=8'.
Finding identical cells in module `$paramod\comparison_2\M=8\K=8'.
Finding identical cells in module `$paramod\division\M=8\K=8'.
Finding identical cells in module `$paramod\division_1\M=8\K=8'.
Finding identical cells in module `$paramod\right_shift_1\M=8\K=8'.
Finding identical cells in module `$paramod\right_shift_2\M=8\K=8'.
Finding identical cells in module `$paramod\sub_and_mul\M=8\K=8'.
Finding identical cells in module `$paramod\u2_to_zm\M=8\K=8'.
Finding identical cells in module `$paramod\zm_to_u2\M=8\K=8'.
Finding identical cells in module `\synth_new_alu'.
Removed a total of 0 cells.

3.20.3. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module $paramod\absolute\M=8\K=8..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module $paramod\add_bit\M=8\K=8..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module $paramod\addition_1\M=8\K=8..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module $paramod\comparison_1\M=8\K=8..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module $paramod\comparison_2\M=8\K=8..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module $paramod\division\M=8\K=8..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module $paramod\division_1\M=8\K=8..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module $paramod\right_shift_1\M=8\K=8..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module $paramod\right_shift_2\M=8\K=8..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module $paramod\sub_and_mul\M=8\K=8..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module $paramod\u2_to_zm\M=8\K=8..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module $paramod\zm_to_u2\M=8\K=8..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \synth_new_alu..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Removed 0 multiplexer ports.
<suppressed ~39 debug messages>

3.20.4. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
  Optimizing cells in module $paramod\absolute\M=8\K=8.
    Consolidated identical input bits for $mux cell $procmux$549:
      Old ports: A={ 31'0000000000000000000000000000000 \cache_result [0] }, B={ 30'000000000000000000000000000000 $add$new_alu.sv:199$297_Y }, Y=$2\x[31:0]
      New ports: A={ 1'0 \cache_result [0] }, B=$add$new_alu.sv:199$297_Y, Y=$2\x[31:0] [1:0]
      New connections: $2\x[31:0] [31:2] = 30'000000000000000000000000000000
  Optimizing cells in module $paramod\absolute\M=8\K=8.
  Optimizing cells in module $paramod\add_bit\M=8\K=8.
    Consolidated identical input bits for $mux cell $procmux$579:
      Old ports: A=4'1001, B=4'0000, Y=$2\cache_status[3:0]
      New ports: A=1'1, B=1'0, Y=$2\cache_status[3:0] [0]
      New connections: $2\cache_status[3:0] [3:1] = { $2\cache_status[3:0] [0] 2'00 }
  Optimizing cells in module $paramod\add_bit\M=8\K=8.
    Consolidated identical input bits for $mux cell $procmux$594:
      Old ports: A=$2\cache_status[3:0], B=4'1001, Y=\cache_status
      New ports: A=$2\cache_status[3:0] [0], B=1'1, Y=\cache_status [0]
      New connections: \cache_status [3:1] = { \cache_status [0] 2'00 }
  Optimizing cells in module $paramod\add_bit\M=8\K=8.
  Optimizing cells in module $paramod\addition_1\M=8\K=8.
    Consolidated identical input bits for $mux cell $procmux$829:
      Old ports: A=4'0000, B=4'1001, Y=$2\cache_status[3:0]
      New ports: A=1'0, B=1'1, Y=$2\cache_status[3:0] [0]
      New connections: $2\cache_status[3:0] [3:1] = { $2\cache_status[3:0] [0] 2'00 }
  Optimizing cells in module $paramod\addition_1\M=8\K=8.
    Consolidated identical input bits for $mux cell $procmux$834:
      Old ports: A=4'0000, B=$2\cache_status[3:0], Y=$1\cache_status[3:0]
      New ports: A=1'0, B=$2\cache_status[3:0] [0], Y=$1\cache_status[3:0] [0]
      New connections: $1\cache_status[3:0] [3:1] = { $1\cache_status[3:0] [0] 2'00 }
  Optimizing cells in module $paramod\addition_1\M=8\K=8.
    Consolidated identical input bits for $mux cell $procmux$790:
      Old ports: A=$1\cache_status[3:0], B=4'1001, Y=$4\cache_status[3:0]
      New ports: A=$1\cache_status[3:0] [0], B=1'1, Y=$4\cache_status[3:0] [0]
      New connections: $4\cache_status[3:0] [3:1] = { $4\cache_status[3:0] [0] 2'00 }
  Optimizing cells in module $paramod\addition_1\M=8\K=8.
    Consolidated identical input bits for $mux cell $procmux$795:
      Old ports: A=$1\cache_status[3:0], B=$4\cache_status[3:0], Y=\cache_status
      New ports: A=$1\cache_status[3:0] [0], B=$4\cache_status[3:0] [0], Y=\cache_status [0]
      New connections: \cache_status [3:1] = { \cache_status [0] 2'00 }
  Optimizing cells in module $paramod\addition_1\M=8\K=8.
  Optimizing cells in module $paramod\comparison_1\M=8\K=8.
  Optimizing cells in module $paramod\comparison_2\M=8\K=8.
    Consolidated identical input bits for $mux cell $procmux$612:
      Old ports: A=8'00000000, B={ 7'0000000 $6\cache_result[7:0] }, Y=$5\cache_result[7:0]
      New ports: A=1'0, B=$6\cache_result[7:0], Y=$5\cache_result[7:0] [0]
      New connections: $5\cache_result[7:0] [7:1] = 7'0000000
  Optimizing cells in module $paramod\comparison_2\M=8\K=8.
    Consolidated identical input bits for $mux cell $procmux$687:
      Old ports: A=$5\cache_result[7:0], B={ 7'0000000 $4\cache_result[7:0] }, Y=$3\cache_result[7:0]
      New ports: A=$5\cache_result[7:0] [0], B=$4\cache_result[7:0], Y=$3\cache_result[7:0] [0]
      New connections: $3\cache_result[7:0] [7:1] = 7'0000000
  Optimizing cells in module $paramod\comparison_2\M=8\K=8.
    Consolidated identical input bits for $mux cell $procmux$714:
      Old ports: A=$3\cache_result[7:0], B=8'00000000, Y=$2\cache_result[7:0]
      New ports: A=$3\cache_result[7:0] [0], B=1'0, Y=$2\cache_result[7:0] [0]
      New connections: $2\cache_result[7:0] [7:1] = 7'0000000
  Optimizing cells in module $paramod\comparison_2\M=8\K=8.
    Consolidated identical input bits for $mux cell $procmux$732:
      Old ports: A=$2\cache_result[7:0], B=8'00000001, Y=\cache_result
      New ports: A=$2\cache_result[7:0] [0], B=1'1, Y=\cache_result [0]
      New connections: \cache_result [7:1] = 7'0000000
  Optimizing cells in module $paramod\comparison_2\M=8\K=8.
  Optimizing cells in module $paramod\division\M=8\K=8.
    Consolidated identical input bits for $mux cell $procmux$480:
      Old ports: A={ 31'0000000000000000000000000000000 \cache_result [0] }, B={ 30'000000000000000000000000000000 $add$new_alu.sv:284$353_Y }, Y=$2\x[31:0]
      New ports: A={ 1'0 \cache_result [0] }, B=$add$new_alu.sv:284$353_Y, Y=$2\x[31:0] [1:0]
      New connections: $2\x[31:0] [31:2] = 30'000000000000000000000000000000
  Optimizing cells in module $paramod\division\M=8\K=8.
  Optimizing cells in module $paramod\division_1\M=8\K=8.
    Consolidated identical input bits for $mux cell $procmux$780:
      Old ports: A=4'0000, B=4'1000, Y=\cache_status
      New ports: A=1'0, B=1'1, Y=\cache_status [3]
      New connections: \cache_status [2:0] = 3'000
  Optimizing cells in module $paramod\division_1\M=8\K=8.
  Optimizing cells in module $paramod\right_shift_1\M=8\K=8.
    Consolidated identical input bits for $mux cell $procmux$774:
      Old ports: A=4'1000, B=4'0000, Y=\cache_status
      New ports: A=1'1, B=1'0, Y=\cache_status [3]
      New connections: \cache_status [2:0] = 3'000
  Optimizing cells in module $paramod\right_shift_1\M=8\K=8.
  Optimizing cells in module $paramod\right_shift_2\M=8\K=8.
    Consolidated identical input bits for $mux cell $procmux$426:
      Old ports: A={ 31'0000000000000000000000000000000 \cache_result [0] }, B={ 30'000000000000000000000000000000 $add$new_alu.sv:338$387_Y }, Y=$2\x[31:0]
      New ports: A={ 1'0 \cache_result [0] }, B=$add$new_alu.sv:338$387_Y, Y=$2\x[31:0] [1:0]
      New connections: $2\x[31:0] [31:2] = 30'000000000000000000000000000000
  Optimizing cells in module $paramod\right_shift_2\M=8\K=8.
  Optimizing cells in module $paramod\sub_and_mul\M=8\K=8.
    Consolidated identical input bits for $mux cell $procmux$747:
      Old ports: A=4'1001, B=4'0000, Y=$2\cache_status[3:0]
      New ports: A=1'1, B=1'0, Y=$2\cache_status[3:0] [0]
      New connections: $2\cache_status[3:0] [3:1] = { $2\cache_status[3:0] [0] 2'00 }
  Optimizing cells in module $paramod\sub_and_mul\M=8\K=8.
    Consolidated identical input bits for $mux cell $procmux$762:
      Old ports: A=$2\cache_status[3:0], B=4'1001, Y=\cache_status
      New ports: A=$2\cache_status[3:0] [0], B=1'1, Y=\cache_status [0]
      New connections: \cache_status [3:1] = { \cache_status [0] 2'00 }
  Optimizing cells in module $paramod\sub_and_mul\M=8\K=8.
  Optimizing cells in module $paramod\u2_to_zm\M=8\K=8.
    Consolidated identical input bits for $mux cell $procmux$570:
      Old ports: A=4'0000, B=4'1001, Y=\cache_status
      New ports: A=1'0, B=1'1, Y=\cache_status [0]
      New connections: \cache_status [3:1] = { \cache_status [0] 2'00 }
  Optimizing cells in module $paramod\u2_to_zm\M=8\K=8.
  Optimizing cells in module $paramod\zm_to_u2\M=8\K=8.
  Optimizing cells in module \synth_new_alu.
Performed a total of 18 changes.

3.20.5. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `$paramod\absolute\M=8\K=8'.
Finding identical cells in module `$paramod\add_bit\M=8\K=8'.
Finding identical cells in module `$paramod\addition_1\M=8\K=8'.
Finding identical cells in module `$paramod\comparison_1\M=8\K=8'.
Finding identical cells in module `$paramod\comparison_2\M=8\K=8'.
Finding identical cells in module `$paramod\division\M=8\K=8'.
Finding identical cells in module `$paramod\division_1\M=8\K=8'.
Finding identical cells in module `$paramod\right_shift_1\M=8\K=8'.
Finding identical cells in module `$paramod\right_shift_2\M=8\K=8'.
Finding identical cells in module `$paramod\sub_and_mul\M=8\K=8'.
Finding identical cells in module `$paramod\u2_to_zm\M=8\K=8'.
Finding identical cells in module `$paramod\zm_to_u2\M=8\K=8'.
Finding identical cells in module `\synth_new_alu'.
Removed a total of 0 cells.

3.20.6. Executing OPT_RMDFF pass (remove dff with constant values).

3.20.7. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module $paramod\absolute\M=8\K=8..
Finding unused cells or wires in module $paramod\add_bit\M=8\K=8..
Finding unused cells or wires in module $paramod\addition_1\M=8\K=8..
Finding unused cells or wires in module $paramod\comparison_1\M=8\K=8..
Finding unused cells or wires in module $paramod\comparison_2\M=8\K=8..
Finding unused cells or wires in module $paramod\division\M=8\K=8..
Finding unused cells or wires in module $paramod\division_1\M=8\K=8..
Finding unused cells or wires in module $paramod\right_shift_1\M=8\K=8..
Finding unused cells or wires in module $paramod\right_shift_2\M=8\K=8..
Finding unused cells or wires in module $paramod\sub_and_mul\M=8\K=8..
Finding unused cells or wires in module $paramod\u2_to_zm\M=8\K=8..
Finding unused cells or wires in module $paramod\zm_to_u2\M=8\K=8..
Finding unused cells or wires in module \synth_new_alu..

3.20.8. Executing OPT_EXPR pass (perform const folding).
Optimizing module $paramod\absolute\M=8\K=8.
Optimizing module $paramod\add_bit\M=8\K=8.
<suppressed ~2 debug messages>
Optimizing module $paramod\addition_1\M=8\K=8.
<suppressed ~3 debug messages>
Optimizing module $paramod\comparison_1\M=8\K=8.
Optimizing module $paramod\comparison_2\M=8\K=8.
<suppressed ~2 debug messages>
Optimizing module $paramod\division\M=8\K=8.
Optimizing module $paramod\division_1\M=8\K=8.
<suppressed ~1 debug messages>
Optimizing module $paramod\right_shift_1\M=8\K=8.
<suppressed ~1 debug messages>
Optimizing module $paramod\right_shift_2\M=8\K=8.
Optimizing module $paramod\sub_and_mul\M=8\K=8.
<suppressed ~2 debug messages>
Optimizing module $paramod\u2_to_zm\M=8\K=8.
<suppressed ~1 debug messages>
Optimizing module $paramod\zm_to_u2\M=8\K=8.
Optimizing module synth_new_alu.

3.20.9. Rerunning OPT passes. (Maybe there is more to do..)

3.20.10. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module $paramod\absolute\M=8\K=8..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module $paramod\add_bit\M=8\K=8..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module $paramod\addition_1\M=8\K=8..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module $paramod\comparison_1\M=8\K=8..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module $paramod\comparison_2\M=8\K=8..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module $paramod\division\M=8\K=8..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module $paramod\division_1\M=8\K=8..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module $paramod\right_shift_1\M=8\K=8..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module $paramod\right_shift_2\M=8\K=8..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module $paramod\sub_and_mul\M=8\K=8..
  Creating internal representation of mux trees.
  No muxes found in this module.
Running muxtree optimizer on module $paramod\u2_to_zm\M=8\K=8..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module $paramod\zm_to_u2\M=8\K=8..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Running muxtree optimizer on module \synth_new_alu..
  Creating internal representation of mux trees.
  Evaluating internal representation of mux trees.
  Analyzing evaluation results.
Removed 0 multiplexer ports.
<suppressed ~33 debug messages>

3.20.11. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
  Optimizing cells in module $paramod\absolute\M=8\K=8.
  Optimizing cells in module $paramod\add_bit\M=8\K=8.
  Optimizing cells in module $paramod\addition_1\M=8\K=8.
  Optimizing cells in module $paramod\comparison_1\M=8\K=8.
  Optimizing cells in module $paramod\comparison_2\M=8\K=8.
  Optimizing cells in module $paramod\division\M=8\K=8.
  Optimizing cells in module $paramod\division_1\M=8\K=8.
  Optimizing cells in module $paramod\right_shift_1\M=8\K=8.
  Optimizing cells in module $paramod\right_shift_2\M=8\K=8.
  Optimizing cells in module $paramod\sub_and_mul\M=8\K=8.
  Optimizing cells in module $paramod\u2_to_zm\M=8\K=8.
  Optimizing cells in module $paramod\zm_to_u2\M=8\K=8.
  Optimizing cells in module \synth_new_alu.
Performed a total of 0 changes.

3.20.12. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `$paramod\absolute\M=8\K=8'.
Finding identical cells in module `$paramod\add_bit\M=8\K=8'.
Finding identical cells in module `$paramod\addition_1\M=8\K=8'.
Finding identical cells in module `$paramod\comparison_1\M=8\K=8'.
Finding identical cells in module `$paramod\comparison_2\M=8\K=8'.
Finding identical cells in module `$paramod\division\M=8\K=8'.
Finding identical cells in module `$paramod\division_1\M=8\K=8'.
Finding identical cells in module `$paramod\right_shift_1\M=8\K=8'.
Finding identical cells in module `$paramod\right_shift_2\M=8\K=8'.
Finding identical cells in module `$paramod\sub_and_mul\M=8\K=8'.
Finding identical cells in module `$paramod\u2_to_zm\M=8\K=8'.
Finding identical cells in module `$paramod\zm_to_u2\M=8\K=8'.
Finding identical cells in module `\synth_new_alu'.
Removed a total of 0 cells.

3.20.13. Executing OPT_RMDFF pass (remove dff with constant values).

3.20.14. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module $paramod\absolute\M=8\K=8..
Finding unused cells or wires in module $paramod\add_bit\M=8\K=8..
Finding unused cells or wires in module $paramod\addition_1\M=8\K=8..
Finding unused cells or wires in module $paramod\comparison_1\M=8\K=8..
Finding unused cells or wires in module $paramod\comparison_2\M=8\K=8..
Finding unused cells or wires in module $paramod\division\M=8\K=8..
Finding unused cells or wires in module $paramod\division_1\M=8\K=8..
Finding unused cells or wires in module $paramod\right_shift_1\M=8\K=8..
Finding unused cells or wires in module $paramod\right_shift_2\M=8\K=8..
Finding unused cells or wires in module $paramod\sub_and_mul\M=8\K=8..
Finding unused cells or wires in module $paramod\u2_to_zm\M=8\K=8..
Finding unused cells or wires in module $paramod\zm_to_u2\M=8\K=8..
Finding unused cells or wires in module \synth_new_alu..
Removed 0 unused cells and 3 unused wires.
<suppressed ~3 debug messages>

3.20.15. Executing OPT_EXPR pass (perform const folding).
Optimizing module $paramod\absolute\M=8\K=8.
Optimizing module $paramod\add_bit\M=8\K=8.
Optimizing module $paramod\addition_1\M=8\K=8.
Optimizing module $paramod\comparison_1\M=8\K=8.
Optimizing module $paramod\comparison_2\M=8\K=8.
Optimizing module $paramod\division\M=8\K=8.
Optimizing module $paramod\division_1\M=8\K=8.
Optimizing module $paramod\right_shift_1\M=8\K=8.
Optimizing module $paramod\right_shift_2\M=8\K=8.
Optimizing module $paramod\sub_and_mul\M=8\K=8.
Optimizing module $paramod\u2_to_zm\M=8\K=8.
Optimizing module $paramod\zm_to_u2\M=8\K=8.
Optimizing module synth_new_alu.

3.20.16. Finished OPT passes. (There is nothing left to do.)

3.21. Executing TECHMAP pass (map to technology primitives).

3.21.1. Executing Verilog-2005 frontend: <techmap.v>
Parsing Verilog input from `<techmap.v>' to AST representation.
Generating RTLIL representation for module `\_90_simplemap_bool_ops'.
Generating RTLIL representation for module `\_90_simplemap_reduce_ops'.
Generating RTLIL representation for module `\_90_simplemap_logic_ops'.
Generating RTLIL representation for module `\_90_simplemap_compare_ops'.
Generating RTLIL representation for module `\_90_simplemap_various'.
Generating RTLIL representation for module `\_90_simplemap_registers'.
Generating RTLIL representation for module `\_90_shift_ops_shr_shl_sshl_sshr'.
Generating RTLIL representation for module `\_90_shift_shiftx'.
Generating RTLIL representation for module `\_90_fa'.
Generating RTLIL representation for module `\_90_lcu'.
Generating RTLIL representation for module `\_90_alu'.
Generating RTLIL representation for module `\_90_macc'.
Generating RTLIL representation for module `\_90_alumacc'.
Generating RTLIL representation for module `\$__div_mod_u'.
Generating RTLIL representation for module `\$__div_mod'.
Generating RTLIL representation for module `\_90_div'.
Generating RTLIL representation for module `\_90_mod'.
Generating RTLIL representation for module `\_90_pow'.
Generating RTLIL representation for module `\_90_pmux'.
Generating RTLIL representation for module `\_90_lut'.
Successfully finished Verilog frontend.

3.21.2. Continuing TECHMAP pass.
Using extmapper simplemap for cells of type $logic_not.
Using extmapper simplemap for cells of type $reduce_xor.
Using extmapper simplemap for cells of type $mux.
Using extmapper simplemap for cells of type $not.
Using extmapper simplemap for cells of type $or.
Using extmapper simplemap for cells of type $eq.
Using template $paramod\_90_pmux\WIDTH=8\S_WIDTH=3 for cells of type $pmux.
Using template $paramod\_90_pmux\WIDTH=4\S_WIDTH=3 for cells of type $pmux.
Using extmapper simplemap for cells of type $dff.
Using extmapper simplemap for cells of type $reduce_or.
Using extmapper simplemap for cells of type $and.
Using extmapper simplemap for cells of type $reduce_and.
Using template $paramod\_90_alu\A_SIGNED=0\B_SIGNED=0\A_WIDTH=7\B_WIDTH=7\Y_WIDTH=8 for cells of type $alu.
Using template $paramod\_90_alu\A_SIGNED=0\B_SIGNED=0\A_WIDTH=7\B_WIDTH=7\Y_WIDTH=7 for cells of type $alu.
Using template $paramod\_90_alu\A_SIGNED=0\B_SIGNED=0\A_WIDTH=8\B_WIDTH=8\Y_WIDTH=8 for cells of type $alu.
Using extmapper simplemap for cells of type $xor.
Using template $paramod\_90_lcu\WIDTH=8 for cells of type $lcu.
Using extmapper simplemap for cells of type $pos.
Using template $paramod\_90_lcu\WIDTH=7 for cells of type $lcu.
Using template $paramod\_90_div\A_SIGNED=0\B_SIGNED=0\A_WIDTH=7\B_WIDTH=7\Y_WIDTH=7 for cells of type $div.
Using template $paramod\$__div_mod\A_SIGNED=0\B_SIGNED=0\A_WIDTH=7\B_WIDTH=7\Y_WIDTH=7 for cells of type $__div_mod.
Running "alumacc" on wrapper $extern:wrap:$neg:Y_WIDTH=7:A_WIDTH=7:A_SIGNED=0:394426c56d1a028ba8fdd5469b163e04011def47.
Using template $extern:wrap:$neg:Y_WIDTH=7:A_WIDTH=7:A_SIGNED=0:394426c56d1a028ba8fdd5469b163e04011def47 for cells of type $extern:wrap:$neg:Y_WIDTH=7:A_WIDTH=7:A_SIGNED=0:394426c56d1a028ba8fdd5469b163e04011def47.
Using extmapper simplemap for cells of type $logic_and.
Using extmapper simplemap for cells of type $ne.
Using template $paramod\$__div_mod_u\WIDTH=7 for cells of type $__div_mod_u.
Using template $paramod\_90_alu\A_SIGNED=0\B_SIGNED=0\A_WIDTH=0\B_WIDTH=7\Y_WIDTH=7 for cells of type $alu.
Running "alumacc" on wrapper $extern:wrap:$sub:Y_WIDTH=7:B_WIDTH=7:A_WIDTH=7:B_SIGNED=0:A_SIGNED=0:394426c56d1a028ba8fdd5469b163e04011def47.
Using template $extern:wrap:$sub:Y_WIDTH=7:B_WIDTH=7:A_WIDTH=7:B_SIGNED=0:A_SIGNED=0:394426c56d1a028ba8fdd5469b163e04011def47 for cells of type $extern:wrap:$sub:Y_WIDTH=7:B_WIDTH=7:A_WIDTH=7:B_SIGNED=0:A_SIGNED=0:394426c56d1a028ba8fdd5469b163e04011def47.
Running "alumacc" on wrapper $extern:wrap:$ge:Y_WIDTH=1:B_WIDTH=7:A_WIDTH=7:B_SIGNED=0:A_SIGNED=0:394426c56d1a028ba8fdd5469b163e04011def47.
Using template $extern:wrap:$ge:Y_WIDTH=1:B_WIDTH=7:A_WIDTH=7:B_SIGNED=0:A_SIGNED=0:394426c56d1a028ba8fdd5469b163e04011def47 for cells of type $extern:wrap:$ge:Y_WIDTH=1:B_WIDTH=7:A_WIDTH=7:B_SIGNED=0:A_SIGNED=0:394426c56d1a028ba8fdd5469b163e04011def47.
Running "alumacc" on wrapper $extern:wrap:$sub:Y_WIDTH=8:B_WIDTH=8:A_WIDTH=7:B_SIGNED=0:A_SIGNED=0:394426c56d1a028ba8fdd5469b163e04011def47.
Using template $extern:wrap:$sub:Y_WIDTH=8:B_WIDTH=8:A_WIDTH=7:B_SIGNED=0:A_SIGNED=0:394426c56d1a028ba8fdd5469b163e04011def47 for cells of type $extern:wrap:$sub:Y_WIDTH=8:B_WIDTH=8:A_WIDTH=7:B_SIGNED=0:A_SIGNED=0:394426c56d1a028ba8fdd5469b163e04011def47.
Running "alumacc" on wrapper $extern:wrap:$ge:Y_WIDTH=1:B_WIDTH=8:A_WIDTH=7:B_SIGNED=0:A_SIGNED=0:394426c56d1a028ba8fdd5469b163e04011def47.
Using template $extern:wrap:$ge:Y_WIDTH=1:B_WIDTH=8:A_WIDTH=7:B_SIGNED=0:A_SIGNED=0:394426c56d1a028ba8fdd5469b163e04011def47 for cells of type $extern:wrap:$ge:Y_WIDTH=1:B_WIDTH=8:A_WIDTH=7:B_SIGNED=0:A_SIGNED=0:394426c56d1a028ba8fdd5469b163e04011def47.
Running "alumacc" on wrapper $extern:wrap:$sub:Y_WIDTH=9:B_WIDTH=9:A_WIDTH=7:B_SIGNED=0:A_SIGNED=0:394426c56d1a028ba8fdd5469b163e04011def47.
Using template $extern:wrap:$sub:Y_WIDTH=9:B_WIDTH=9:A_WIDTH=7:B_SIGNED=0:A_SIGNED=0:394426c56d1a028ba8fdd5469b163e04011def47 for cells of type $extern:wrap:$sub:Y_WIDTH=9:B_WIDTH=9:A_WIDTH=7:B_SIGNED=0:A_SIGNED=0:394426c56d1a028ba8fdd5469b163e04011def47.
Running "alumacc" on wrapper $extern:wrap:$ge:Y_WIDTH=1:B_WIDTH=9:A_WIDTH=7:B_SIGNED=0:A_SIGNED=0:394426c56d1a028ba8fdd5469b163e04011def47.
Using template $extern:wrap:$ge:Y_WIDTH=1:B_WIDTH=9:A_WIDTH=7:B_SIGNED=0:A_SIGNED=0:394426c56d1a028ba8fdd5469b163e04011def47 for cells of type $extern:wrap:$ge:Y_WIDTH=1:B_WIDTH=9:A_WIDTH=7:B_SIGNED=0:A_SIGNED=0:394426c56d1a028ba8fdd5469b163e04011def47.
Running "alumacc" on wrapper $extern:wrap:$sub:Y_WIDTH=10:B_WIDTH=10:A_WIDTH=7:B_SIGNED=0:A_SIGNED=0:394426c56d1a028ba8fdd5469b163e04011def47.
Using template $extern:wrap:$sub:Y_WIDTH=10:B_WIDTH=10:A_WIDTH=7:B_SIGNED=0:A_SIGNED=0:394426c56d1a028ba8fdd5469b163e04011def47 for cells of type $extern:wrap:$sub:Y_WIDTH=10:B_WIDTH=10:A_WIDTH=7:B_SIGNED=0:A_SIGNED=0:394426c56d1a028ba8fdd5469b163e04011def47.
Running "alumacc" on wrapper $extern:wrap:$ge:Y_WIDTH=1:B_WIDTH=10:A_WIDTH=7:B_SIGNED=0:A_SIGNED=0:394426c56d1a028ba8fdd5469b163e04011def47.
Using template $extern:wrap:$ge:Y_WIDTH=1:B_WIDTH=10:A_WIDTH=7:B_SIGNED=0:A_SIGNED=0:394426c56d1a028ba8fdd5469b163e04011def47 for cells of type $extern:wrap:$ge:Y_WIDTH=1:B_WIDTH=10:A_WIDTH=7:B_SIGNED=0:A_SIGNED=0:394426c56d1a028ba8fdd5469b163e04011def47.
Running "alumacc" on wrapper $extern:wrap:$sub:Y_WIDTH=11:B_WIDTH=11:A_WIDTH=7:B_SIGNED=0:A_SIGNED=0:394426c56d1a028ba8fdd5469b163e04011def47.
Using template $extern:wrap:$sub:Y_WIDTH=11:B_WIDTH=11:A_WIDTH=7:B_SIGNED=0:A_SIGNED=0:394426c56d1a028ba8fdd5469b163e04011def47 for cells of type $extern:wrap:$sub:Y_WIDTH=11:B_WIDTH=11:A_WIDTH=7:B_SIGNED=0:A_SIGNED=0:394426c56d1a028ba8fdd5469b163e04011def47.
Running "alumacc" on wrapper $extern:wrap:$ge:Y_WIDTH=1:B_WIDTH=11:A_WIDTH=7:B_SIGNED=0:A_SIGNED=0:394426c56d1a028ba8fdd5469b163e04011def47.
Using template $extern:wrap:$ge:Y_WIDTH=1:B_WIDTH=11:A_WIDTH=7:B_SIGNED=0:A_SIGNED=0:394426c56d1a028ba8fdd5469b163e04011def47 for cells of type $extern:wrap:$ge:Y_WIDTH=1:B_WIDTH=11:A_WIDTH=7:B_SIGNED=0:A_SIGNED=0:394426c56d1a028ba8fdd5469b163e04011def47.
Running "alumacc" on wrapper $extern:wrap:$sub:Y_WIDTH=12:B_WIDTH=12:A_WIDTH=7:B_SIGNED=0:A_SIGNED=0:394426c56d1a028ba8fdd5469b163e04011def47.
Using template $extern:wrap:$sub:Y_WIDTH=12:B_WIDTH=12:A_WIDTH=7:B_SIGNED=0:A_SIGNED=0:394426c56d1a028ba8fdd5469b163e04011def47 for cells of type $extern:wrap:$sub:Y_WIDTH=12:B_WIDTH=12:A_WIDTH=7:B_SIGNED=0:A_SIGNED=0:394426c56d1a028ba8fdd5469b163e04011def47.
Running "alumacc" on wrapper $extern:wrap:$ge:Y_WIDTH=1:B_WIDTH=12:A_WIDTH=7:B_SIGNED=0:A_SIGNED=0:394426c56d1a028ba8fdd5469b163e04011def47.
Using template $extern:wrap:$ge:Y_WIDTH=1:B_WIDTH=12:A_WIDTH=7:B_SIGNED=0:A_SIGNED=0:394426c56d1a028ba8fdd5469b163e04011def47 for cells of type $extern:wrap:$ge:Y_WIDTH=1:B_WIDTH=12:A_WIDTH=7:B_SIGNED=0:A_SIGNED=0:394426c56d1a028ba8fdd5469b163e04011def47.
Running "alumacc" on wrapper $extern:wrap:$sub:Y_WIDTH=13:B_WIDTH=13:A_WIDTH=7:B_SIGNED=0:A_SIGNED=0:394426c56d1a028ba8fdd5469b163e04011def47.
Using template $extern:wrap:$sub:Y_WIDTH=13:B_WIDTH=13:A_WIDTH=7:B_SIGNED=0:A_SIGNED=0:394426c56d1a028ba8fdd5469b163e04011def47 for cells of type $extern:wrap:$sub:Y_WIDTH=13:B_WIDTH=13:A_WIDTH=7:B_SIGNED=0:A_SIGNED=0:394426c56d1a028ba8fdd5469b163e04011def47.
Running "alumacc" on wrapper $extern:wrap:$ge:Y_WIDTH=1:B_WIDTH=13:A_WIDTH=7:B_SIGNED=0:A_SIGNED=0:394426c56d1a028ba8fdd5469b163e04011def47.
Using template $extern:wrap:$ge:Y_WIDTH=1:B_WIDTH=13:A_WIDTH=7:B_SIGNED=0:A_SIGNED=0:394426c56d1a028ba8fdd5469b163e04011def47 for cells of type $extern:wrap:$ge:Y_WIDTH=1:B_WIDTH=13:A_WIDTH=7:B_SIGNED=0:A_SIGNED=0:394426c56d1a028ba8fdd5469b163e04011def47.
Using template $paramod\_90_alu\A_SIGNED=0\B_SIGNED=0\A_WIDTH=7\B_WIDTH=8\Y_WIDTH=8 for cells of type $alu.
Using template $paramod\_90_alu\A_SIGNED=0\B_SIGNED=0\A_WIDTH=7\B_WIDTH=9\Y_WIDTH=9 for cells of type $alu.
Using template $paramod\_90_alu\A_SIGNED=0\B_SIGNED=0\A_WIDTH=7\B_WIDTH=10\Y_WIDTH=10 for cells of type $alu.
Using template $paramod\_90_alu\A_SIGNED=0\B_SIGNED=0\A_WIDTH=7\B_WIDTH=11\Y_WIDTH=11 for cells of type $alu.
Using template $paramod\_90_alu\A_SIGNED=0\B_SIGNED=0\A_WIDTH=7\B_WIDTH=12\Y_WIDTH=12 for cells of type $alu.
Using template $paramod\_90_alu\A_SIGNED=0\B_SIGNED=0\A_WIDTH=7\B_WIDTH=13\Y_WIDTH=13 for cells of type $alu.
Using template $paramod\_90_lcu\WIDTH=9 for cells of type $lcu.
Using template $paramod\_90_lcu\WIDTH=10 for cells of type $lcu.
Using template $paramod\_90_lcu\WIDTH=11 for cells of type $lcu.
Using template $paramod\_90_lcu\WIDTH=12 for cells of type $lcu.
Using template $paramod\_90_lcu\WIDTH=13 for cells of type $lcu.
Using template $paramod$constmap:f99840ec908483ed147148e5b457b3755f98764b$paramod$4fe8c41c92de264026421898d6dc634764eb5260\_90_shift_ops_shr_shl_sshl_sshr for cells of type $shr.
Using template $paramod\_90_alu\A_SIGNED=0\B_SIGNED=0\A_WIDTH=1\B_WIDTH=7\Y_WIDTH=7 for cells of type $alu.
Using template $paramod\_90_alu\A_SIGNED=1\B_SIGNED=1\A_WIDTH=8\B_WIDTH=8\Y_WIDTH=8 for cells of type $alu.
Using template $paramod\_90_alu\A_SIGNED=1\B_SIGNED=1\A_WIDTH=8\B_WIDTH=8\Y_WIDTH=32 for cells of type $alu.
Using template $paramod\_90_alu\A_SIGNED=1\B_SIGNED=1\A_WIDTH=8\B_WIDTH=32\Y_WIDTH=32 for cells of type $alu.
Using template $paramod\_90_lcu\WIDTH=32 for cells of type $lcu.
Using extmapper simplemap for cells of type $logic_or.
Using template $paramod\_90_alu\A_SIGNED=1\B_SIGNED=1\A_WIDTH=8\B_WIDTH=8\Y_WIDTH=9 for cells of type $alu.
Using template $paramod$constmap:72cdabb1749dac72049399dad655ca81335c3226$paramod$1387be111640f0925da5b53545d9af31cb93b7de\_90_shift_ops_shr_shl_sshl_sshr for cells of type $shl.
Using template $paramod\_90_alu\A_SIGNED=1\B_SIGNED=1\A_WIDTH=2\B_WIDTH=32\Y_WIDTH=32 for cells of type $alu.
Using template $paramod\_90_alu\A_SIGNED=1\B_SIGNED=1\A_WIDTH=1\B_WIDTH=8\Y_WIDTH=8 for cells of type $alu.
Using template $paramod\_90_alu\A_SIGNED=0\B_SIGNED=0\A_WIDTH=0\B_WIDTH=8\Y_WIDTH=8 for cells of type $alu.
Using template $paramod\_90_alu\A_SIGNED=1\B_SIGNED=1\A_WIDTH=8\B_WIDTH=9\Y_WIDTH=9 for cells of type $alu.
Using extmapper simplemap for cells of type $eqx.
Using extmapper simplemap for cells of type $reduce_bool.
Using template $paramod\_90_alu\A_SIGNED=0\B_SIGNED=0\A_WIDTH=1\B_WIDTH=1\Y_WIDTH=2 for cells of type $alu.
Using template $paramod\_90_lcu\WIDTH=2 for cells of type $lcu.
Using template $paramod\_90_div\A_SIGNED=1\B_SIGNED=1\A_WIDTH=8\B_WIDTH=8\Y_WIDTH=8 for cells of type $div.
Using extmapper simplemap for cells of type $nex.
Using template $paramod\_90_alu\A_SIGNED=1\B_SIGNED=1\A_WIDTH=4\B_WIDTH=8\Y_WIDTH=8 for cells of type $alu.
Using template $paramod\$__div_mod\A_SIGNED=1\B_SIGNED=1\A_WIDTH=8\B_WIDTH=8\Y_WIDTH=8 for cells of type $__div_mod.
Running "alumacc" on wrapper $extern:wrap:$neg:Y_WIDTH=8:A_WIDTH=8:A_SIGNED=0:394426c56d1a028ba8fdd5469b163e04011def47.
Using template $extern:wrap:$neg:Y_WIDTH=8:A_WIDTH=8:A_SIGNED=0:394426c56d1a028ba8fdd5469b163e04011def47 for cells of type $extern:wrap:$neg:Y_WIDTH=8:A_WIDTH=8:A_SIGNED=0:394426c56d1a028ba8fdd5469b163e04011def47.
Using template $paramod\$__div_mod_u\WIDTH=8 for cells of type $__div_mod_u.
Running "alumacc" on wrapper $extern:wrap:$sub:Y_WIDTH=8:B_WIDTH=8:A_WIDTH=8:B_SIGNED=0:A_SIGNED=0:394426c56d1a028ba8fdd5469b163e04011def47.
Using template $extern:wrap:$sub:Y_WIDTH=8:B_WIDTH=8:A_WIDTH=8:B_SIGNED=0:A_SIGNED=0:394426c56d1a028ba8fdd5469b163e04011def47 for cells of type $extern:wrap:$sub:Y_WIDTH=8:B_WIDTH=8:A_WIDTH=8:B_SIGNED=0:A_SIGNED=0:394426c56d1a028ba8fdd5469b163e04011def47.
Running "alumacc" on wrapper $extern:wrap:$ge:Y_WIDTH=1:B_WIDTH=8:A_WIDTH=8:B_SIGNED=0:A_SIGNED=0:394426c56d1a028ba8fdd5469b163e04011def47.
Using template $extern:wrap:$ge:Y_WIDTH=1:B_WIDTH=8:A_WIDTH=8:B_SIGNED=0:A_SIGNED=0:394426c56d1a028ba8fdd5469b163e04011def47 for cells of type $extern:wrap:$ge:Y_WIDTH=1:B_WIDTH=8:A_WIDTH=8:B_SIGNED=0:A_SIGNED=0:394426c56d1a028ba8fdd5469b163e04011def47.
Running "alumacc" on wrapper $extern:wrap:$sub:Y_WIDTH=9:B_WIDTH=9:A_WIDTH=8:B_SIGNED=0:A_SIGNED=0:394426c56d1a028ba8fdd5469b163e04011def47.
Using template $extern:wrap:$sub:Y_WIDTH=9:B_WIDTH=9:A_WIDTH=8:B_SIGNED=0:A_SIGNED=0:394426c56d1a028ba8fdd5469b163e04011def47 for cells of type $extern:wrap:$sub:Y_WIDTH=9:B_WIDTH=9:A_WIDTH=8:B_SIGNED=0:A_SIGNED=0:394426c56d1a028ba8fdd5469b163e04011def47.
Running "alumacc" on wrapper $extern:wrap:$ge:Y_WIDTH=1:B_WIDTH=9:A_WIDTH=8:B_SIGNED=0:A_SIGNED=0:394426c56d1a028ba8fdd5469b163e04011def47.
Using template $extern:wrap:$ge:Y_WIDTH=1:B_WIDTH=9:A_WIDTH=8:B_SIGNED=0:A_SIGNED=0:394426c56d1a028ba8fdd5469b163e04011def47 for cells of type $extern:wrap:$ge:Y_WIDTH=1:B_WIDTH=9:A_WIDTH=8:B_SIGNED=0:A_SIGNED=0:394426c56d1a028ba8fdd5469b163e04011def47.
Running "alumacc" on wrapper $extern:wrap:$sub:Y_WIDTH=10:B_WIDTH=10:A_WIDTH=8:B_SIGNED=0:A_SIGNED=0:394426c56d1a028ba8fdd5469b163e04011def47.
Using template $extern:wrap:$sub:Y_WIDTH=10:B_WIDTH=10:A_WIDTH=8:B_SIGNED=0:A_SIGNED=0:394426c56d1a028ba8fdd5469b163e04011def47 for cells of type $extern:wrap:$sub:Y_WIDTH=10:B_WIDTH=10:A_WIDTH=8:B_SIGNED=0:A_SIGNED=0:394426c56d1a028ba8fdd5469b163e04011def47.
Running "alumacc" on wrapper $extern:wrap:$ge:Y_WIDTH=1:B_WIDTH=10:A_WIDTH=8:B_SIGNED=0:A_SIGNED=0:394426c56d1a028ba8fdd5469b163e04011def47.
Using template $extern:wrap:$ge:Y_WIDTH=1:B_WIDTH=10:A_WIDTH=8:B_SIGNED=0:A_SIGNED=0:394426c56d1a028ba8fdd5469b163e04011def47 for cells of type $extern:wrap:$ge:Y_WIDTH=1:B_WIDTH=10:A_WIDTH=8:B_SIGNED=0:A_SIGNED=0:394426c56d1a028ba8fdd5469b163e04011def47.
Running "alumacc" on wrapper $extern:wrap:$sub:Y_WIDTH=11:B_WIDTH=11:A_WIDTH=8:B_SIGNED=0:A_SIGNED=0:394426c56d1a028ba8fdd5469b163e04011def47.
Using template $extern:wrap:$sub:Y_WIDTH=11:B_WIDTH=11:A_WIDTH=8:B_SIGNED=0:A_SIGNED=0:394426c56d1a028ba8fdd5469b163e04011def47 for cells of type $extern:wrap:$sub:Y_WIDTH=11:B_WIDTH=11:A_WIDTH=8:B_SIGNED=0:A_SIGNED=0:394426c56d1a028ba8fdd5469b163e04011def47.
Running "alumacc" on wrapper $extern:wrap:$ge:Y_WIDTH=1:B_WIDTH=11:A_WIDTH=8:B_SIGNED=0:A_SIGNED=0:394426c56d1a028ba8fdd5469b163e04011def47.
Using template $extern:wrap:$ge:Y_WIDTH=1:B_WIDTH=11:A_WIDTH=8:B_SIGNED=0:A_SIGNED=0:394426c56d1a028ba8fdd5469b163e04011def47 for cells of type $extern:wrap:$ge:Y_WIDTH=1:B_WIDTH=11:A_WIDTH=8:B_SIGNED=0:A_SIGNED=0:394426c56d1a028ba8fdd5469b163e04011def47.
Running "alumacc" on wrapper $extern:wrap:$sub:Y_WIDTH=12:B_WIDTH=12:A_WIDTH=8:B_SIGNED=0:A_SIGNED=0:394426c56d1a028ba8fdd5469b163e04011def47.
Using template $extern:wrap:$sub:Y_WIDTH=12:B_WIDTH=12:A_WIDTH=8:B_SIGNED=0:A_SIGNED=0:394426c56d1a028ba8fdd5469b163e04011def47 for cells of type $extern:wrap:$sub:Y_WIDTH=12:B_WIDTH=12:A_WIDTH=8:B_SIGNED=0:A_SIGNED=0:394426c56d1a028ba8fdd5469b163e04011def47.
Running "alumacc" on wrapper $extern:wrap:$ge:Y_WIDTH=1:B_WIDTH=12:A_WIDTH=8:B_SIGNED=0:A_SIGNED=0:394426c56d1a028ba8fdd5469b163e04011def47.
Using template $extern:wrap:$ge:Y_WIDTH=1:B_WIDTH=12:A_WIDTH=8:B_SIGNED=0:A_SIGNED=0:394426c56d1a028ba8fdd5469b163e04011def47 for cells of type $extern:wrap:$ge:Y_WIDTH=1:B_WIDTH=12:A_WIDTH=8:B_SIGNED=0:A_SIGNED=0:394426c56d1a028ba8fdd5469b163e04011def47.
Running "alumacc" on wrapper $extern:wrap:$sub:Y_WIDTH=13:B_WIDTH=13:A_WIDTH=8:B_SIGNED=0:A_SIGNED=0:394426c56d1a028ba8fdd5469b163e04011def47.
Using template $extern:wrap:$sub:Y_WIDTH=13:B_WIDTH=13:A_WIDTH=8:B_SIGNED=0:A_SIGNED=0:394426c56d1a028ba8fdd5469b163e04011def47 for cells of type $extern:wrap:$sub:Y_WIDTH=13:B_WIDTH=13:A_WIDTH=8:B_SIGNED=0:A_SIGNED=0:394426c56d1a028ba8fdd5469b163e04011def47.
Running "alumacc" on wrapper $extern:wrap:$ge:Y_WIDTH=1:B_WIDTH=13:A_WIDTH=8:B_SIGNED=0:A_SIGNED=0:394426c56d1a028ba8fdd5469b163e04011def47.
Using template $extern:wrap:$ge:Y_WIDTH=1:B_WIDTH=13:A_WIDTH=8:B_SIGNED=0:A_SIGNED=0:394426c56d1a028ba8fdd5469b163e04011def47 for cells of type $extern:wrap:$ge:Y_WIDTH=1:B_WIDTH=13:A_WIDTH=8:B_SIGNED=0:A_SIGNED=0:394426c56d1a028ba8fdd5469b163e04011def47.
Running "alumacc" on wrapper $extern:wrap:$sub:Y_WIDTH=14:B_WIDTH=14:A_WIDTH=8:B_SIGNED=0:A_SIGNED=0:394426c56d1a028ba8fdd5469b163e04011def47.
Using template $extern:wrap:$sub:Y_WIDTH=14:B_WIDTH=14:A_WIDTH=8:B_SIGNED=0:A_SIGNED=0:394426c56d1a028ba8fdd5469b163e04011def47 for cells of type $extern:wrap:$sub:Y_WIDTH=14:B_WIDTH=14:A_WIDTH=8:B_SIGNED=0:A_SIGNED=0:394426c56d1a028ba8fdd5469b163e04011def47.
Running "alumacc" on wrapper $extern:wrap:$ge:Y_WIDTH=1:B_WIDTH=14:A_WIDTH=8:B_SIGNED=0:A_SIGNED=0:394426c56d1a028ba8fdd5469b163e04011def47.
Using template $extern:wrap:$ge:Y_WIDTH=1:B_WIDTH=14:A_WIDTH=8:B_SIGNED=0:A_SIGNED=0:394426c56d1a028ba8fdd5469b163e04011def47 for cells of type $extern:wrap:$ge:Y_WIDTH=1:B_WIDTH=14:A_WIDTH=8:B_SIGNED=0:A_SIGNED=0:394426c56d1a028ba8fdd5469b163e04011def47.
Running "alumacc" on wrapper $extern:wrap:$sub:Y_WIDTH=15:B_WIDTH=15:A_WIDTH=8:B_SIGNED=0:A_SIGNED=0:394426c56d1a028ba8fdd5469b163e04011def47.
Using template $extern:wrap:$sub:Y_WIDTH=15:B_WIDTH=15:A_WIDTH=8:B_SIGNED=0:A_SIGNED=0:394426c56d1a028ba8fdd5469b163e04011def47 for cells of type $extern:wrap:$sub:Y_WIDTH=15:B_WIDTH=15:A_WIDTH=8:B_SIGNED=0:A_SIGNED=0:394426c56d1a028ba8fdd5469b163e04011def47.
Running "alumacc" on wrapper $extern:wrap:$ge:Y_WIDTH=1:B_WIDTH=15:A_WIDTH=8:B_SIGNED=0:A_SIGNED=0:394426c56d1a028ba8fdd5469b163e04011def47.
Using template $extern:wrap:$ge:Y_WIDTH=1:B_WIDTH=15:A_WIDTH=8:B_SIGNED=0:A_SIGNED=0:394426c56d1a028ba8fdd5469b163e04011def47 for cells of type $extern:wrap:$ge:Y_WIDTH=1:B_WIDTH=15:A_WIDTH=8:B_SIGNED=0:A_SIGNED=0:394426c56d1a028ba8fdd5469b163e04011def47.
Using template $paramod\_90_alu\A_SIGNED=0\B_SIGNED=0\A_WIDTH=8\B_WIDTH=9\Y_WIDTH=9 for cells of type $alu.
Using template $paramod\_90_alu\A_SIGNED=0\B_SIGNED=0\A_WIDTH=8\B_WIDTH=10\Y_WIDTH=10 for cells of type $alu.
Using template $paramod\_90_alu\A_SIGNED=0\B_SIGNED=0\A_WIDTH=8\B_WIDTH=11\Y_WIDTH=11 for cells of type $alu.
Using template $paramod\_90_alu\A_SIGNED=0\B_SIGNED=0\A_WIDTH=8\B_WIDTH=12\Y_WIDTH=12 for cells of type $alu.
Using template $paramod\_90_alu\A_SIGNED=0\B_SIGNED=0\A_WIDTH=8\B_WIDTH=13\Y_WIDTH=13 for cells of type $alu.
Using template $paramod\_90_alu\A_SIGNED=0\B_SIGNED=0\A_WIDTH=8\B_WIDTH=14\Y_WIDTH=14 for cells of type $alu.
Using template $paramod\_90_alu\A_SIGNED=0\B_SIGNED=0\A_WIDTH=8\B_WIDTH=15\Y_WIDTH=15 for cells of type $alu.
Using template $paramod\_90_lcu\WIDTH=14 for cells of type $lcu.
Using template $paramod\_90_lcu\WIDTH=15 for cells of type $lcu.
Using template $paramod$constmap:f99840ec908483ed147148e5b457b3755f98764b$paramod$a994d635ece46f3516cb80eb323a930c616d0a01\_90_shift_ops_shr_shl_sshl_sshr for cells of type $shr.
Using template $paramod\_90_alu\A_SIGNED=0\B_SIGNED=0\A_WIDTH=3\B_WIDTH=8\Y_WIDTH=8 for cells of type $alu.
No more expansions possible.
<suppressed ~9113 debug messages>

3.22. Executing OPT pass (performing simple optimizations).

3.22.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module $paramod\absolute\M=8\K=8.
<suppressed ~2052 debug messages>
Optimizing module $paramod\add_bit\M=8\K=8.
<suppressed ~273 debug messages>
Optimizing module $paramod\addition_1\M=8\K=8.
<suppressed ~78 debug messages>
Optimizing module $paramod\comparison_1\M=8\K=8.
<suppressed ~20 debug messages>
Optimizing module $paramod\comparison_2\M=8\K=8.
<suppressed ~19 debug messages>
Optimizing module $paramod\division\M=8\K=8.
<suppressed ~2745 debug messages>
Optimizing module $paramod\division_1\M=8\K=8.
<suppressed ~640 debug messages>
Optimizing module $paramod\right_shift_1\M=8\K=8.
<suppressed ~32 debug messages>
Optimizing module $paramod\right_shift_2\M=8\K=8.
<suppressed ~1985 debug messages>
Optimizing module $paramod\sub_and_mul\M=8\K=8.
<suppressed ~296 debug messages>
Optimizing module $paramod\u2_to_zm\M=8\K=8.
<suppressed ~57 debug messages>
Optimizing module $paramod\zm_to_u2\M=8\K=8.
<suppressed ~42 debug messages>
Optimizing module synth_new_alu.
<suppressed ~4 debug messages>

3.22.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `$paramod\absolute\M=8\K=8'.
<suppressed ~228 debug messages>
Finding identical cells in module `$paramod\add_bit\M=8\K=8'.
<suppressed ~720 debug messages>
Finding identical cells in module `$paramod\addition_1\M=8\K=8'.
<suppressed ~138 debug messages>
Finding identical cells in module `$paramod\comparison_1\M=8\K=8'.
<suppressed ~12 debug messages>
Finding identical cells in module `$paramod\comparison_2\M=8\K=8'.
<suppressed ~159 debug messages>
Finding identical cells in module `$paramod\division\M=8\K=8'.
<suppressed ~1896 debug messages>
Finding identical cells in module `$paramod\division_1\M=8\K=8'.
<suppressed ~1443 debug messages>
Finding identical cells in module `$paramod\right_shift_1\M=8\K=8'.
<suppressed ~3 debug messages>
Finding identical cells in module `$paramod\right_shift_2\M=8\K=8'.
<suppressed ~36 debug messages>
Finding identical cells in module `$paramod\sub_and_mul\M=8\K=8'.
<suppressed ~735 debug messages>
Finding identical cells in module `$paramod\u2_to_zm\M=8\K=8'.
Finding identical cells in module `$paramod\zm_to_u2\M=8\K=8'.
Finding identical cells in module `\synth_new_alu'.
<suppressed ~45 debug messages>
Removed a total of 1805 cells.

3.22.3. Executing OPT_RMDFF pass (remove dff with constant values).

3.22.4. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module $paramod\absolute\M=8\K=8..
Finding unused cells or wires in module $paramod\add_bit\M=8\K=8..
Finding unused cells or wires in module $paramod\addition_1\M=8\K=8..
Finding unused cells or wires in module $paramod\comparison_1\M=8\K=8..
Finding unused cells or wires in module $paramod\comparison_2\M=8\K=8..
Finding unused cells or wires in module $paramod\division\M=8\K=8..
Finding unused cells or wires in module $paramod\division_1\M=8\K=8..
Finding unused cells or wires in module $paramod\right_shift_1\M=8\K=8..
Finding unused cells or wires in module $paramod\right_shift_2\M=8\K=8..
Finding unused cells or wires in module $paramod\sub_and_mul\M=8\K=8..
Finding unused cells or wires in module $paramod\u2_to_zm\M=8\K=8..
Finding unused cells or wires in module $paramod\zm_to_u2\M=8\K=8..
Finding unused cells or wires in module \synth_new_alu..
Removed 972 unused cells and 6054 unused wires.
<suppressed ~985 debug messages>

3.22.5. Finished fast OPT passes.

3.23. Executing ABC pass (technology mapping using ABC).

3.23.1. Extracting gate netlist of module `$paramod\absolute\M=8\K=8' to `<abc-temp-dir>/input.blif'..
Extracted 126 gates and 135 wires to a netlist network with 8 inputs and 11 outputs.

3.23.1.1. Executing ABC.
Running ABC command: berkeley-abc -s -f <abc-temp-dir>/abc.script 2>&1
ABC: ABC command line: "source <abc-temp-dir>/abc.script".
ABC: 
ABC: + read_blif <abc-temp-dir>/input.blif 
ABC: + read_library <abc-temp-dir>/stdcells.genlib 
ABC: Entered genlib library with 17 gates from file "<abc-temp-dir>/stdcells.genlib".
ABC: + strash 
ABC: + dretime 
ABC: + retime 
ABC: + map 
ABC: + write_blif <abc-temp-dir>/output.blif 

3.23.1.2. Re-integrating ABC results.
ABC RESULTS:               AND cells:        1
ABC RESULTS:            ANDNOT cells:       12
ABC RESULTS:              AOI3 cells:        2
ABC RESULTS:               MUX cells:        7
ABC RESULTS:              NAND cells:        3
ABC RESULTS:               NOR cells:        5
ABC RESULTS:               NOT cells:        6
ABC RESULTS:              OAI3 cells:        1
ABC RESULTS:                OR cells:       10
ABC RESULTS:             ORNOT cells:        2
ABC RESULTS:              XNOR cells:        3
ABC RESULTS:               XOR cells:       12
ABC RESULTS:        internal signals:      116
ABC RESULTS:           input signals:        8
ABC RESULTS:          output signals:       11
Removing temp directory.

3.23.2. Extracting gate netlist of module `$paramod\add_bit\M=8\K=8' to `<abc-temp-dir>/input.blif'..
Extracted 181 gates and 199 wires to a netlist network with 16 inputs and 9 outputs.

3.23.2.1. Executing ABC.
Running ABC command: berkeley-abc -s -f <abc-temp-dir>/abc.script 2>&1
ABC: ABC command line: "source <abc-temp-dir>/abc.script".
ABC: 
ABC: + read_blif <abc-temp-dir>/input.blif 
ABC: + read_library <abc-temp-dir>/stdcells.genlib 
ABC: Entered genlib library with 17 gates from file "<abc-temp-dir>/stdcells.genlib".
ABC: + strash 
ABC: + dretime 
ABC: + retime 
ABC: + map 
ABC: + write_blif <abc-temp-dir>/output.blif 

3.23.2.2. Re-integrating ABC results.
ABC RESULTS:               AND cells:        3
ABC RESULTS:            ANDNOT cells:       26
ABC RESULTS:              AOI3 cells:       11
ABC RESULTS:              NAND cells:        6
ABC RESULTS:               NOR cells:        2
ABC RESULTS:               NOT cells:        9
ABC RESULTS:              OAI3 cells:        6
ABC RESULTS:              OAI4 cells:        1
ABC RESULTS:                OR cells:       13
ABC RESULTS:             ORNOT cells:        4
ABC RESULTS:              XNOR cells:        7
ABC RESULTS:               XOR cells:        9
ABC RESULTS:        internal signals:      174
ABC RESULTS:           input signals:       16
ABC RESULTS:          output signals:        9
Removing temp directory.

3.23.3. Extracting gate netlist of module `$paramod\addition_1\M=8\K=8' to `<abc-temp-dir>/input.blif'..
Extracted 187 gates and 205 wires to a netlist network with 16 inputs and 9 outputs.

3.23.3.1. Executing ABC.
Running ABC command: berkeley-abc -s -f <abc-temp-dir>/abc.script 2>&1
ABC: ABC command line: "source <abc-temp-dir>/abc.script".
ABC: 
ABC: + read_blif <abc-temp-dir>/input.blif 
ABC: + read_library <abc-temp-dir>/stdcells.genlib 
ABC: Entered genlib library with 17 gates from file "<abc-temp-dir>/stdcells.genlib".
ABC: + strash 
ABC: + dretime 
ABC: + retime 
ABC: + map 
ABC: + write_blif <abc-temp-dir>/output.blif 

3.23.3.2. Re-integrating ABC results.
ABC RESULTS:               AND cells:       10
ABC RESULTS:            ANDNOT cells:       25
ABC RESULTS:              AOI3 cells:       11
ABC RESULTS:               MUX cells:       28
ABC RESULTS:              NAND cells:        6
ABC RESULTS:               NOR cells:        7
ABC RESULTS:               NOT cells:       13
ABC RESULTS:              OAI3 cells:        7
ABC RESULTS:                OR cells:       13
ABC RESULTS:             ORNOT cells:        6
ABC RESULTS:              XNOR cells:       10
ABC RESULTS:               XOR cells:       17
ABC RESULTS:        internal signals:      180
ABC RESULTS:           input signals:       16
ABC RESULTS:          output signals:        9
Removing temp directory.

3.23.4. Extracting gate netlist of module `$paramod\comparison_1\M=8\K=8' to `<abc-temp-dir>/input.blif'..
Extracted 54 gates and 71 wires to a netlist network with 16 inputs and 2 outputs.

3.23.4.1. Executing ABC.
Running ABC command: berkeley-abc -s -f <abc-temp-dir>/abc.script 2>&1
ABC: ABC command line: "source <abc-temp-dir>/abc.script".
ABC: 
ABC: + read_blif <abc-temp-dir>/input.blif 
ABC: + read_library <abc-temp-dir>/stdcells.genlib 
ABC: Entered genlib library with 17 gates from file "<abc-temp-dir>/stdcells.genlib".
ABC: + strash 
ABC: + dretime 
ABC: + retime 
ABC: + map 
ABC: + write_blif <abc-temp-dir>/output.blif 

3.23.4.2. Re-integrating ABC results.
ABC RESULTS:               AND cells:        7
ABC RESULTS:            ANDNOT cells:        1
ABC RESULTS:              AOI3 cells:        5
ABC RESULTS:              NAND cells:        2
ABC RESULTS:               NOR cells:        1
ABC RESULTS:              OAI3 cells:        2
ABC RESULTS:                OR cells:        3
ABC RESULTS:             ORNOT cells:        2
ABC RESULTS:              XNOR cells:        3
ABC RESULTS:               XOR cells:        6
ABC RESULTS:              ZERO cells:        1
ABC RESULTS:        internal signals:       53
ABC RESULTS:           input signals:       16
ABC RESULTS:          output signals:        2
Removing temp directory.

3.23.5. Extracting gate netlist of module `$paramod\comparison_2\M=8\K=8' to `<abc-temp-dir>/input.blif'..
Extracted 63 gates and 80 wires to a netlist network with 16 inputs and 1 outputs.

3.23.5.1. Executing ABC.
Running ABC command: berkeley-abc -s -f <abc-temp-dir>/abc.script 2>&1
ABC: ABC command line: "source <abc-temp-dir>/abc.script".
ABC: 
ABC: + read_blif <abc-temp-dir>/input.blif 
ABC: + read_library <abc-temp-dir>/stdcells.genlib 
ABC: Entered genlib library with 17 gates from file "<abc-temp-dir>/stdcells.genlib".
ABC: + strash 
ABC: + dretime 
ABC: + retime 
ABC: + map 
ABC: + write_blif <abc-temp-dir>/output.blif 

3.23.5.2. Re-integrating ABC results.
ABC RESULTS:            ANDNOT cells:       10
ABC RESULTS:              AOI3 cells:        5
ABC RESULTS:               MUX cells:        1
ABC RESULTS:              NAND cells:        4
ABC RESULTS:               NOR cells:        1
ABC RESULTS:               NOT cells:        1
ABC RESULTS:              OAI3 cells:        4
ABC RESULTS:                OR cells:        6
ABC RESULTS:             ORNOT cells:        4
ABC RESULTS:              XNOR cells:        5
ABC RESULTS:               XOR cells:        2
ABC RESULTS:        internal signals:       63
ABC RESULTS:           input signals:       16
ABC RESULTS:          output signals:        1
Removing temp directory.

3.23.6. Extracting gate netlist of module `$paramod\division\M=8\K=8' to `<abc-temp-dir>/input.blif'..
Extracted 711 gates and 729 wires to a netlist network with 16 inputs and 12 outputs.

3.23.6.1. Executing ABC.
Running ABC command: berkeley-abc -s -f <abc-temp-dir>/abc.script 2>&1
ABC: ABC command line: "source <abc-temp-dir>/abc.script".
ABC: 
ABC: + read_blif <abc-temp-dir>/input.blif 
ABC: + read_library <abc-temp-dir>/stdcells.genlib 
ABC: Entered genlib library with 17 gates from file "<abc-temp-dir>/stdcells.genlib".
ABC: + strash 
ABC: + dretime 
ABC: + retime 
ABC: + map 
ABC: + write_blif <abc-temp-dir>/output.blif 

3.23.6.2. Re-integrating ABC results.
ABC RESULTS:               AND cells:       12
ABC RESULTS:            ANDNOT cells:       74
ABC RESULTS:              AOI3 cells:       22
ABC RESULTS:              AOI4 cells:        3
ABC RESULTS:               MUX cells:       61
ABC RESULTS:              NAND cells:       24
ABC RESULTS:               NOR cells:       38
ABC RESULTS:               NOT cells:       30
ABC RESULTS:              OAI3 cells:       34
ABC RESULTS:                OR cells:       71
ABC RESULTS:             ORNOT cells:       18
ABC RESULTS:              XNOR cells:       37
ABC RESULTS:               XOR cells:       60
ABC RESULTS:        internal signals:      701
ABC RESULTS:           input signals:       16
ABC RESULTS:          output signals:       12
Removing temp directory.

3.23.7. Extracting gate netlist of module `$paramod\division_1\M=8\K=8' to `<abc-temp-dir>/input.blif'..
Extracted 406 gates and 423 wires to a netlist network with 16 inputs and 9 outputs.

3.23.7.1. Executing ABC.
Running ABC command: berkeley-abc -s -f <abc-temp-dir>/abc.script 2>&1
ABC: ABC command line: "source <abc-temp-dir>/abc.script".
ABC: 
ABC: + read_blif <abc-temp-dir>/input.blif 
ABC: + read_library <abc-temp-dir>/stdcells.genlib 
ABC: Entered genlib library with 17 gates from file "<abc-temp-dir>/stdcells.genlib".
ABC: + strash 
ABC: + dretime 
ABC: + retime 
ABC: + map 
ABC: + write_blif <abc-temp-dir>/output.blif 

3.23.7.2. Re-integrating ABC results.
ABC RESULTS:               AND cells:        7
ABC RESULTS:            ANDNOT cells:       52
ABC RESULTS:              AOI3 cells:       12
ABC RESULTS:              AOI4 cells:        4
ABC RESULTS:               MUX cells:       24
ABC RESULTS:              NAND cells:        7
ABC RESULTS:               NOR cells:       16
ABC RESULTS:               NOT cells:       21
ABC RESULTS:              OAI3 cells:       19
ABC RESULTS:              OAI4 cells:        2
ABC RESULTS:                OR cells:       48
ABC RESULTS:             ORNOT cells:       12
ABC RESULTS:              XNOR cells:        9
ABC RESULTS:               XOR cells:       41
ABC RESULTS:        internal signals:      398
ABC RESULTS:           input signals:       16
ABC RESULTS:          output signals:        9
Removing temp directory.

3.23.8. Extracting gate netlist of module `$paramod\right_shift_1\M=8\K=8' to `<abc-temp-dir>/input.blif'..
Extracted 47 gates and 64 wires to a netlist network with 16 inputs and 9 outputs.

3.23.8.1. Executing ABC.
Running ABC command: berkeley-abc -s -f <abc-temp-dir>/abc.script 2>&1
ABC: ABC command line: "source <abc-temp-dir>/abc.script".
ABC: 
ABC: + read_blif <abc-temp-dir>/input.blif 
ABC: + read_library <abc-temp-dir>/stdcells.genlib 
ABC: Entered genlib library with 17 gates from file "<abc-temp-dir>/stdcells.genlib".
ABC: + strash 
ABC: + dretime 
ABC: + retime 
ABC: + map 
ABC: + write_blif <abc-temp-dir>/output.blif 

3.23.8.2. Re-integrating ABC results.
ABC RESULTS:            ANDNOT cells:        8
ABC RESULTS:               MUX cells:       17
ABC RESULTS:              NAND cells:        2
ABC RESULTS:               NOT cells:        4
ABC RESULTS:                OR cells:        8
ABC RESULTS:             ORNOT cells:        8
ABC RESULTS:        internal signals:       39
ABC RESULTS:           input signals:       16
ABC RESULTS:          output signals:        9
Removing temp directory.

3.23.9. Extracting gate netlist of module `$paramod\right_shift_2\M=8\K=8' to `<abc-temp-dir>/input.blif'..
Extracted 158 gates and 176 wires to a netlist network with 16 inputs and 12 outputs.

3.23.9.1. Executing ABC.
Running ABC command: berkeley-abc -s -f <abc-temp-dir>/abc.script 2>&1
ABC: ABC command line: "source <abc-temp-dir>/abc.script".
ABC: 
ABC: + read_blif <abc-temp-dir>/input.blif 
ABC: + read_library <abc-temp-dir>/stdcells.genlib 
ABC: Entered genlib library with 17 gates from file "<abc-temp-dir>/stdcells.genlib".
ABC: + strash 
ABC: + dretime 
ABC: + retime 
ABC: + map 
ABC: + write_blif <abc-temp-dir>/output.blif 

3.23.9.2. Re-integrating ABC results.
ABC RESULTS:               AND cells:        1
ABC RESULTS:            ANDNOT cells:        8
ABC RESULTS:              AOI3 cells:        3
ABC RESULTS:               MUX cells:       17
ABC RESULTS:              NAND cells:        4
ABC RESULTS:               NOR cells:       12
ABC RESULTS:               NOT cells:        2
ABC RESULTS:                OR cells:       38
ABC RESULTS:              XNOR cells:        2
ABC RESULTS:               XOR cells:        5
ABC RESULTS:        internal signals:      148
ABC RESULTS:           input signals:       16
ABC RESULTS:          output signals:       12
Removing temp directory.

3.23.10. Extracting gate netlist of module `$paramod\sub_and_mul\M=8\K=8' to `<abc-temp-dir>/input.blif'..
Extracted 343 gates and 359 wires to a netlist network with 15 inputs and 9 outputs.

3.23.10.1. Executing ABC.
Running ABC command: berkeley-abc -s -f <abc-temp-dir>/abc.script 2>&1
ABC: ABC command line: "source <abc-temp-dir>/abc.script".
ABC: 
ABC: + read_blif <abc-temp-dir>/input.blif 
ABC: + read_library <abc-temp-dir>/stdcells.genlib 
ABC: Entered genlib library with 17 gates from file "<abc-temp-dir>/stdcells.genlib".
ABC: + strash 
ABC: + dretime 
ABC: + retime 
ABC: + map 
ABC: + write_blif <abc-temp-dir>/output.blif 

3.23.10.2. Re-integrating ABC results.
ABC RESULTS:               AND cells:        3
ABC RESULTS:            ANDNOT cells:       29
ABC RESULTS:              AOI3 cells:       33
ABC RESULTS:               BUF cells:        1
ABC RESULTS:              NAND cells:        5
ABC RESULTS:               NOR cells:        8
ABC RESULTS:               NOT cells:        7
ABC RESULTS:              OAI3 cells:       15
ABC RESULTS:                OR cells:       18
ABC RESULTS:             ORNOT cells:       26
ABC RESULTS:              XNOR cells:       16
ABC RESULTS:               XOR cells:       27
ABC RESULTS:        internal signals:      335
ABC RESULTS:           input signals:       15
ABC RESULTS:          output signals:        9
Removing temp directory.

3.23.11. Extracting gate netlist of module `$paramod\u2_to_zm\M=8\K=8' to `<abc-temp-dir>/input.blif'..
Extracted 45 gates and 54 wires to a netlist network with 8 inputs and 9 outputs.

3.23.11.1. Executing ABC.
Running ABC command: berkeley-abc -s -f <abc-temp-dir>/abc.script 2>&1
ABC: ABC command line: "source <abc-temp-dir>/abc.script".
ABC: 
ABC: + read_blif <abc-temp-dir>/input.blif 
ABC: + read_library <abc-temp-dir>/stdcells.genlib 
ABC: Entered genlib library with 17 gates from file "<abc-temp-dir>/stdcells.genlib".
ABC: + strash 
ABC: + dretime 
ABC: + retime 
ABC: + map 
ABC: + write_blif <abc-temp-dir>/output.blif 

3.23.11.2. Re-integrating ABC results.
ABC RESULTS:               AND cells:        1
ABC RESULTS:            ANDNOT cells:        4
ABC RESULTS:               MUX cells:       13
ABC RESULTS:               NOR cells:        1
ABC RESULTS:               NOT cells:        1
ABC RESULTS:                OR cells:        7
ABC RESULTS:             ORNOT cells:        2
ABC RESULTS:              XNOR cells:        2
ABC RESULTS:               XOR cells:        4
ABC RESULTS:        internal signals:       37
ABC RESULTS:           input signals:        8
ABC RESULTS:          output signals:        9
Removing temp directory.

3.23.12. Extracting gate netlist of module `$paramod\zm_to_u2\M=8\K=8' to `<abc-temp-dir>/input.blif'..
Extracted 28 gates and 37 wires to a netlist network with 8 inputs and 7 outputs.

3.23.12.1. Executing ABC.
Running ABC command: berkeley-abc -s -f <abc-temp-dir>/abc.script 2>&1
ABC: ABC command line: "source <abc-temp-dir>/abc.script".
ABC: 
ABC: + read_blif <abc-temp-dir>/input.blif 
ABC: + read_library <abc-temp-dir>/stdcells.genlib 
ABC: Entered genlib library with 17 gates from file "<abc-temp-dir>/stdcells.genlib".
ABC: + strash 
ABC: + dretime 
ABC: + retime 
ABC: + map 
ABC: + write_blif <abc-temp-dir>/output.blif 

3.23.12.2. Re-integrating ABC results.
ABC RESULTS:               AND cells:        1
ABC RESULTS:            ANDNOT cells:        3
ABC RESULTS:               MUX cells:        6
ABC RESULTS:               NOR cells:        1
ABC RESULTS:               NOT cells:        1
ABC RESULTS:                OR cells:        4
ABC RESULTS:             ORNOT cells:        1
ABC RESULTS:              XNOR cells:        2
ABC RESULTS:               XOR cells:        4
ABC RESULTS:        internal signals:       22
ABC RESULTS:           input signals:        8
ABC RESULTS:          output signals:        7
Removing temp directory.

3.23.13. Extracting gate netlist of module `\synth_new_alu' to `<abc-temp-dir>/input.blif'..
Extracted 338 gates and 489 wires to a netlist network with 149 inputs and 13 outputs.

3.23.13.1. Executing ABC.
Running ABC command: berkeley-abc -s -f <abc-temp-dir>/abc.script 2>&1
ABC: ABC command line: "source <abc-temp-dir>/abc.script".
ABC: 
ABC: + read_blif <abc-temp-dir>/input.blif 
ABC: + read_library <abc-temp-dir>/stdcells.genlib 
ABC: Entered genlib library with 17 gates from file "<abc-temp-dir>/stdcells.genlib".
ABC: + strash 
ABC: + dretime 
ABC: + retime 
ABC: + map 
ABC: + write_blif <abc-temp-dir>/output.blif 

3.23.13.2. Re-integrating ABC results.
ABC RESULTS:               AND cells:        6
ABC RESULTS:            ANDNOT cells:       60
ABC RESULTS:              AOI3 cells:       16
ABC RESULTS:              AOI4 cells:       38
ABC RESULTS:               MUX cells:       25
ABC RESULTS:              NAND cells:       16
ABC RESULTS:               NOR cells:        2
ABC RESULTS:               NOT cells:       30
ABC RESULTS:              OAI3 cells:       16
ABC RESULTS:              OAI4 cells:       11
ABC RESULTS:                OR cells:        3
ABC RESULTS:             ORNOT cells:       18
ABC RESULTS:              XNOR cells:        1
ABC RESULTS:               XOR cells:        6
ABC RESULTS:        internal signals:      327
ABC RESULTS:           input signals:      149
ABC RESULTS:          output signals:       13
Removing temp directory.

3.24. Executing OPT pass (performing simple optimizations).

3.24.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module $paramod\absolute\M=8\K=8.
<suppressed ~3 debug messages>
Optimizing module $paramod\add_bit\M=8\K=8.
Optimizing module $paramod\addition_1\M=8\K=8.
Optimizing module $paramod\comparison_1\M=8\K=8.
Optimizing module $paramod\comparison_2\M=8\K=8.
Optimizing module $paramod\division\M=8\K=8.
<suppressed ~17 debug messages>
Optimizing module $paramod\division_1\M=8\K=8.
Optimizing module $paramod\right_shift_1\M=8\K=8.
<suppressed ~17 debug messages>
Optimizing module $paramod\right_shift_2\M=8\K=8.
<suppressed ~10 debug messages>
Optimizing module $paramod\sub_and_mul\M=8\K=8.
Optimizing module $paramod\u2_to_zm\M=8\K=8.
<suppressed ~6 debug messages>
Optimizing module $paramod\zm_to_u2\M=8\K=8.
<suppressed ~6 debug messages>
Optimizing module synth_new_alu.

3.24.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `$paramod\absolute\M=8\K=8'.
<suppressed ~3 debug messages>
Finding identical cells in module `$paramod\add_bit\M=8\K=8'.
<suppressed ~6 debug messages>
Finding identical cells in module `$paramod\addition_1\M=8\K=8'.
Finding identical cells in module `$paramod\comparison_1\M=8\K=8'.
Finding identical cells in module `$paramod\comparison_2\M=8\K=8'.
Finding identical cells in module `$paramod\division\M=8\K=8'.
<suppressed ~87 debug messages>
Finding identical cells in module `$paramod\division_1\M=8\K=8'.
<suppressed ~42 debug messages>
Finding identical cells in module `$paramod\right_shift_1\M=8\K=8'.
Finding identical cells in module `$paramod\right_shift_2\M=8\K=8'.
Finding identical cells in module `$paramod\sub_and_mul\M=8\K=8'.
<suppressed ~222 debug messages>
Finding identical cells in module `$paramod\u2_to_zm\M=8\K=8'.
Finding identical cells in module `$paramod\zm_to_u2\M=8\K=8'.
Finding identical cells in module `\synth_new_alu'.
Removed a total of 120 cells.

3.24.3. Executing OPT_RMDFF pass (remove dff with constant values).

3.24.4. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module $paramod\absolute\M=8\K=8..
Finding unused cells or wires in module $paramod\add_bit\M=8\K=8..
Finding unused cells or wires in module $paramod\addition_1\M=8\K=8..
Finding unused cells or wires in module $paramod\comparison_1\M=8\K=8..
Finding unused cells or wires in module $paramod\comparison_2\M=8\K=8..
Finding unused cells or wires in module $paramod\division\M=8\K=8..
Finding unused cells or wires in module $paramod\division_1\M=8\K=8..
Finding unused cells or wires in module $paramod\right_shift_1\M=8\K=8..
Finding unused cells or wires in module $paramod\right_shift_2\M=8\K=8..
Finding unused cells or wires in module $paramod\sub_and_mul\M=8\K=8..
Finding unused cells or wires in module $paramod\u2_to_zm\M=8\K=8..
Finding unused cells or wires in module $paramod\zm_to_u2\M=8\K=8..
Finding unused cells or wires in module \synth_new_alu..
Removed 6 unused cells and 1614 unused wires.
<suppressed ~20 debug messages>

3.24.5. Finished fast OPT passes.

3.25. Executing HIERARCHY pass (managing design hierarchy).

3.25.1. Analyzing design hierarchy..
Top module:  \synth_new_alu
Used module:     $paramod\absolute\M=8\K=8
Used module:     $paramod\add_bit\M=8\K=8
Used module:     $paramod\addition_1\M=8\K=8
Used module:     $paramod\comparison_1\M=8\K=8
Used module:     $paramod\comparison_2\M=8\K=8
Used module:     $paramod\division\M=8\K=8
Used module:     $paramod\division_1\M=8\K=8
Used module:     $paramod\right_shift_1\M=8\K=8
Used module:     $paramod\right_shift_2\M=8\K=8
Used module:     $paramod\sub_and_mul\M=8\K=8
Used module:     $paramod\u2_to_zm\M=8\K=8
Used module:     $paramod\zm_to_u2\M=8\K=8

3.25.2. Analyzing design hierarchy..
Top module:  \synth_new_alu
Used module:     $paramod\absolute\M=8\K=8
Used module:     $paramod\add_bit\M=8\K=8
Used module:     $paramod\addition_1\M=8\K=8
Used module:     $paramod\comparison_1\M=8\K=8
Used module:     $paramod\comparison_2\M=8\K=8
Used module:     $paramod\division\M=8\K=8
Used module:     $paramod\division_1\M=8\K=8
Used module:     $paramod\right_shift_1\M=8\K=8
Used module:     $paramod\right_shift_2\M=8\K=8
Used module:     $paramod\sub_and_mul\M=8\K=8
Used module:     $paramod\u2_to_zm\M=8\K=8
Used module:     $paramod\zm_to_u2\M=8\K=8
Removed 0 unused modules.

3.26. Printing statistics.

=== $paramod\absolute\M=8\K=8 ===

   Number of wires:                 56
   Number of wire bits:            135
   Number of public wires:           5
   Number of public wire bits:      84
   Number of memories:               0
   Number of memory bits:            0
   Number of processes:              0
   Number of cells:                 62
     $_ANDNOT_                      12
     $_AND_                          1
     $_AOI3_                         2
     $_MUX_                          7
     $_NAND_                         3
     $_NOR_                          5
     $_NOT_                          5
     $_OAI3_                         1
     $_ORNOT_                        2
     $_OR_                           9
     $_XNOR_                         3
     $_XOR_                         12

=== $paramod\add_bit\M=8\K=8 ===

   Number of wires:                 92
   Number of wire bits:            130
   Number of public wires:           6
   Number of public wire bits:      44
   Number of memories:               0
   Number of memory bits:            0
   Number of processes:              0
   Number of cells:                 95
     $_ANDNOT_                      25
     $_AND_                          3
     $_AOI3_                        11
     $_NAND_                         6
     $_NOR_                          2
     $_NOT_                          9
     $_OAI3_                         6
     $_OAI4_                         1
     $_ORNOT_                        4
     $_OR_                          12
     $_XNOR_                         7
     $_XOR_                          9

=== $paramod\addition_1\M=8\K=8 ===

   Number of wires:                148
   Number of wire bits:            172
   Number of public wires:           4
   Number of public wire bits:      28
   Number of memories:               0
   Number of memory bits:            0
   Number of processes:              0
   Number of cells:                153
     $_ANDNOT_                      25
     $_AND_                         10
     $_AOI3_                        11
     $_MUX_                         28
     $_NAND_                         6
     $_NOR_                          7
     $_NOT_                         13
     $_OAI3_                         7
     $_ORNOT_                        6
     $_OR_                          13
     $_XNOR_                        10
     $_XOR_                         17

=== $paramod\comparison_1\M=8\K=8 ===

   Number of wires:                 37
   Number of wire bits:            123
   Number of public wires:           6
   Number of public wire bits:      92
   Number of memories:               0
   Number of memory bits:            0
   Number of processes:              0
   Number of cells:                 32
     $_ANDNOT_                       1
     $_AND_                          7
     $_AOI3_                         5
     $_NAND_                         2
     $_NOR_                          1
     $_OAI3_                         2
     $_ORNOT_                        2
     $_OR_                           3
     $_XNOR_                         3
     $_XOR_                          6

=== $paramod\comparison_2\M=8\K=8 ===

   Number of wires:                 46
   Number of wire bits:             70
   Number of public wires:           4
   Number of public wire bits:      28
   Number of memories:               0
   Number of memory bits:            0
   Number of processes:              0
   Number of cells:                 43
     $_ANDNOT_                      10
     $_AOI3_                         5
     $_MUX_                          1
     $_NAND_                         4
     $_NOR_                          1
     $_NOT_                          1
     $_OAI3_                         4
     $_ORNOT_                        4
     $_OR_                           6
     $_XNOR_                         5
     $_XOR_                          2

=== $paramod\division\M=8\K=8 ===

   Number of wires:                448
   Number of wire bits:            534
   Number of public wires:           6
   Number of public wire bits:      92
   Number of memories:               0
   Number of memory bits:            0
   Number of processes:              0
   Number of cells:                454
     $_ANDNOT_                      66
     $_AND_                         12
     $_AOI3_                        22
     $_AOI4_                         3
     $_MUX_                         52
     $_NAND_                        20
     $_NOR_                         38
     $_NOT_                         29
     $_OAI3_                        34
     $_ORNOT_                       18
     $_OR_                          63
     $_XNOR_                        37
     $_XOR_                         60

=== $paramod\division_1\M=8\K=8 ===

   Number of wires:                255
   Number of wire bits:            279
   Number of public wires:           4
   Number of public wire bits:      28
   Number of memories:               0
   Number of memory bits:            0
   Number of processes:              0
   Number of cells:                260
     $_ANDNOT_                      50
     $_AND_                          7
     $_AOI3_                        12
     $_AOI4_                         4
     $_MUX_                         24
     $_NAND_                         7
     $_NOR_                         15
     $_NOT_                         21
     $_OAI3_                        19
     $_OAI4_                         2
     $_ORNOT_                       11
     $_OR_                          38
     $_XNOR_                         9
     $_XOR_                         41

=== $paramod\right_shift_1\M=8\K=8 ===

   Number of wires:                 42
   Number of wire bits:             66
   Number of public wires:           4
   Number of public wire bits:      28
   Number of memories:               0
   Number of memory bits:            0
   Number of processes:              0
   Number of cells:                 47
     $_ANDNOT_                       8
     $_MUX_                         17
     $_NAND_                         2
     $_NOT_                          4
     $_ORNOT_                        8
     $_OR_                           8

=== $paramod\right_shift_2\M=8\K=8 ===

   Number of wires:                 84
   Number of wire bits:            170
   Number of public wires:           6
   Number of public wire bits:      92
   Number of memories:               0
   Number of memory bits:            0
   Number of processes:              0
   Number of cells:                 90
     $_ANDNOT_                       8
     $_AND_                          1
     $_AOI3_                         3
     $_MUX_                         17
     $_NAND_                         4
     $_NOR_                         12
     $_OR_                          38
     $_XNOR_                         2
     $_XOR_                          5

=== $paramod\sub_and_mul\M=8\K=8 ===

   Number of wires:                112
   Number of wire bits:            157
   Number of public wires:           7
   Number of public wire bits:      52
   Number of memories:               0
   Number of memory bits:            0
   Number of processes:              0
   Number of cells:                113
     $_ANDNOT_                      21
     $_AND_                          3
     $_AOI3_                        11
     $_NAND_                         5
     $_NOR_                          6
     $_NOT_                          7
     $_OAI3_                        13
     $_ORNOT_                       12
     $_OR_                          14
     $_XNOR_                         8
     $_XOR_                         13

=== $paramod\u2_to_zm\M=8\K=8 ===

   Number of wires:                 29
   Number of wire bits:             53
   Number of public wires:           4
   Number of public wire bits:      28
   Number of memories:               0
   Number of memory bits:            0
   Number of processes:              0
   Number of cells:                 34
     $_ANDNOT_                       4
     $_AND_                          1
     $_MUX_                         13
     $_NOR_                          1
     $_ORNOT_                        2
     $_OR_                           7
     $_XNOR_                         2
     $_XOR_                          4

=== $paramod\zm_to_u2\M=8\K=8 ===

   Number of wires:                 19
   Number of wire bits:             43
   Number of public wires:           4
   Number of public wire bits:      28
   Number of memories:               0
   Number of memory bits:            0
   Number of processes:              0
   Number of cells:                 22
     $_ANDNOT_                       3
     $_AND_                          1
     $_MUX_                          6
     $_NOR_                          1
     $_ORNOT_                        1
     $_OR_                           4
     $_XNOR_                         2
     $_XOR_                          4

=== synth_new_alu ===

   Number of wires:                272
   Number of wire bits:            429
   Number of public wires:          37
   Number of public wire bits:     194
   Number of memories:               0
   Number of memory bits:            0
   Number of processes:              0
   Number of cells:                273
     $_ANDNOT_                      60
     $_AND_                          6
     $_AOI3_                        16
     $_AOI4_                        38
     $_DFF_P_                       13
     $_MUX_                         25
     $_NAND_                        16
     $_NOR_                          2
     $_NOT_                         30
     $_OAI3_                        16
     $_OAI4_                        11
     $_ORNOT_                       18
     $_OR_                           3
     $_XNOR_                         1
     $_XOR_                          6
     $paramod\absolute\M=8\K=8       1
     $paramod\add_bit\M=8\K=8        1
     $paramod\addition_1\M=8\K=8      1
     $paramod\comparison_1\M=8\K=8      1
     $paramod\comparison_2\M=8\K=8      1
     $paramod\division\M=8\K=8       1
     $paramod\division_1\M=8\K=8      1
     $paramod\right_shift_1\M=8\K=8      1
     $paramod\right_shift_2\M=8\K=8      1
     $paramod\sub_and_mul\M=8\K=8      1
     $paramod\u2_to_zm\M=8\K=8       1
     $paramod\zm_to_u2\M=8\K=8       1

=== design hierarchy ===

   synth_new_alu                     1
     $paramod\absolute\M=8\K=8       1
     $paramod\add_bit\M=8\K=8        1
     $paramod\addition_1\M=8\K=8      1
     $paramod\comparison_1\M=8\K=8      1
     $paramod\comparison_2\M=8\K=8      1
     $paramod\division\M=8\K=8       1
     $paramod\division_1\M=8\K=8      1
     $paramod\right_shift_1\M=8\K=8      1
     $paramod\right_shift_2\M=8\K=8      1
     $paramod\sub_and_mul\M=8\K=8      1
     $paramod\u2_to_zm\M=8\K=8       1
     $paramod\zm_to_u2\M=8\K=8       1

   Number of wires:               1640
   Number of wire bits:           2361
   Number of public wires:          97
   Number of public wire bits:     818
   Number of memories:               0
   Number of memory bits:            0
   Number of processes:              0
   Number of cells:               1666
     $_ANDNOT_                     293
     $_AND_                         52
     $_AOI3_                        98
     $_AOI4_                        45
     $_DFF_P_                       13
     $_MUX_                        190
     $_NAND_                        75
     $_NOR_                         91
     $_NOT_                        119
     $_OAI3_                       102
     $_OAI4_                        14
     $_ORNOT_                       88
     $_OR_                         218
     $_XNOR_                        89
     $_XOR_                        179

3.27. Executing CHECK pass (checking for obvious problems).
checking module $paramod\absolute\M=8\K=8..
checking module $paramod\add_bit\M=8\K=8..
checking module $paramod\addition_1\M=8\K=8..
checking module $paramod\comparison_1\M=8\K=8..
checking module $paramod\comparison_2\M=8\K=8..
checking module $paramod\division\M=8\K=8..
checking module $paramod\division_1\M=8\K=8..
checking module $paramod\right_shift_1\M=8\K=8..
checking module $paramod\right_shift_2\M=8\K=8..
checking module $paramod\sub_and_mul\M=8\K=8..
checking module $paramod\u2_to_zm\M=8\K=8..
checking module $paramod\zm_to_u2\M=8\K=8..
checking module synth_new_alu..
found and reported 0 problems.

4. Executing ABC pass (technology mapping using ABC).

4.1. Extracting gate netlist of module `$paramod\absolute\M=8\K=8' to `<abc-temp-dir>/input.blif'..
Extracted 62 gates and 70 wires to a netlist network with 8 inputs and 11 outputs.

4.1.1. Executing ABC.
Running ABC command: berkeley-abc -s -f <abc-temp-dir>/abc.script 2>&1
ABC: ABC command line: "source <abc-temp-dir>/abc.script".
ABC: 
ABC: + read_blif <abc-temp-dir>/input.blif 
ABC: + read_library <abc-temp-dir>/stdcells.genlib 
ABC: Entered genlib library with 7 gates from file "<abc-temp-dir>/stdcells.genlib".
ABC: + strash 
ABC: + ifraig 
ABC: + scorr 
ABC: Warning: The network is combinational (run "fraig" or "fraig_sweep").
ABC: + dc2 
ABC: + dretime 
ABC: + retime 
ABC: + strash 
ABC: + &get -n 
ABC: + &dch -f 
ABC: + &nf 
ABC: + &put 
ABC: + write_blif <abc-temp-dir>/output.blif 

4.1.2. Re-integrating ABC results.
ABC RESULTS:               AND cells:       14
ABC RESULTS:               BUF cells:        1
ABC RESULTS:               NOT cells:        9
ABC RESULTS:                OR cells:        8
ABC RESULTS:               XOR cells:       11
ABC RESULTS:              ZERO cells:        2
ABC RESULTS:        internal signals:       51
ABC RESULTS:           input signals:        8
ABC RESULTS:          output signals:       11
Removing temp directory.

4.2. Extracting gate netlist of module `$paramod\add_bit\M=8\K=8' to `<abc-temp-dir>/input.blif'..
Extracted 95 gates and 111 wires to a netlist network with 16 inputs and 9 outputs.

4.2.1. Executing ABC.
Running ABC command: berkeley-abc -s -f <abc-temp-dir>/abc.script 2>&1
ABC: ABC command line: "source <abc-temp-dir>/abc.script".
ABC: 
ABC: + read_blif <abc-temp-dir>/input.blif 
ABC: + read_library <abc-temp-dir>/stdcells.genlib 
ABC: Entered genlib library with 7 gates from file "<abc-temp-dir>/stdcells.genlib".
ABC: + strash 
ABC: + ifraig 
ABC: + scorr 
ABC: Warning: The network is combinational (run "fraig" or "fraig_sweep").
ABC: + dc2 
ABC: + dretime 
ABC: + retime 
ABC: + strash 
ABC: + &get -n 
ABC: + &dch -f 
ABC: + &nf 
ABC: + &put 
ABC: + write_blif <abc-temp-dir>/output.blif 

4.2.2. Re-integrating ABC results.
ABC RESULTS:               AND cells:       24
ABC RESULTS:               NOT cells:        4
ABC RESULTS:                OR cells:       28
ABC RESULTS:               XOR cells:       15
ABC RESULTS:        internal signals:       86
ABC RESULTS:           input signals:       16
ABC RESULTS:          output signals:        9
Removing temp directory.

4.3. Extracting gate netlist of module `$paramod\addition_1\M=8\K=8' to `<abc-temp-dir>/input.blif'..
Extracted 153 gates and 169 wires to a netlist network with 16 inputs and 9 outputs.

4.3.1. Executing ABC.
Running ABC command: berkeley-abc -s -f <abc-temp-dir>/abc.script 2>&1
ABC: ABC command line: "source <abc-temp-dir>/abc.script".
ABC: 
ABC: + read_blif <abc-temp-dir>/input.blif 
ABC: + read_library <abc-temp-dir>/stdcells.genlib 
ABC: Entered genlib library with 7 gates from file "<abc-temp-dir>/stdcells.genlib".
ABC: + strash 
ABC: + ifraig 
ABC: + scorr 
ABC: Warning: The network is combinational (run "fraig" or "fraig_sweep").
ABC: + dc2 
ABC: + dretime 
ABC: + retime 
ABC: + strash 
ABC: + &get -n 
ABC: + &dch -f 
ABC: + &nf 
ABC: + &put 
ABC: + write_blif <abc-temp-dir>/output.blif 

4.3.2. Re-integrating ABC results.
ABC RESULTS:               AND cells:       55
ABC RESULTS:               NOT cells:       23
ABC RESULTS:                OR cells:       56
ABC RESULTS:               XOR cells:       13
ABC RESULTS:        internal signals:      144
ABC RESULTS:           input signals:       16
ABC RESULTS:          output signals:        9
Removing temp directory.

4.4. Extracting gate netlist of module `$paramod\comparison_1\M=8\K=8' to `<abc-temp-dir>/input.blif'..
Extracted 32 gates and 48 wires to a netlist network with 16 inputs and 1 outputs.

4.4.1. Executing ABC.
Running ABC command: berkeley-abc -s -f <abc-temp-dir>/abc.script 2>&1
ABC: ABC command line: "source <abc-temp-dir>/abc.script".
ABC: 
ABC: + read_blif <abc-temp-dir>/input.blif 
ABC: + read_library <abc-temp-dir>/stdcells.genlib 
ABC: Entered genlib library with 7 gates from file "<abc-temp-dir>/stdcells.genlib".
ABC: + strash 
ABC: + ifraig 
ABC: + scorr 
ABC: Warning: The network is combinational (run "fraig" or "fraig_sweep").
ABC: + dc2 
ABC: + dretime 
ABC: + retime 
ABC: + strash 
ABC: + &get -n 
ABC: + &dch -f 
ABC: + &nf 
ABC: + &put 
ABC: + write_blif <abc-temp-dir>/output.blif 

4.4.2. Re-integrating ABC results.
ABC RESULTS:               AND cells:       21
ABC RESULTS:               NOT cells:       10
ABC RESULTS:                OR cells:       18
ABC RESULTS:               XOR cells:        2
ABC RESULTS:        internal signals:       31
ABC RESULTS:           input signals:       16
ABC RESULTS:          output signals:        1
Removing temp directory.

4.5. Extracting gate netlist of module `$paramod\comparison_2\M=8\K=8' to `<abc-temp-dir>/input.blif'..
Extracted 43 gates and 59 wires to a netlist network with 16 inputs and 1 outputs.

4.5.1. Executing ABC.
Running ABC command: berkeley-abc -s -f <abc-temp-dir>/abc.script 2>&1
ABC: ABC command line: "source <abc-temp-dir>/abc.script".
ABC: 
ABC: + read_blif <abc-temp-dir>/input.blif 
ABC: + read_library <abc-temp-dir>/stdcells.genlib 
ABC: Entered genlib library with 7 gates from file "<abc-temp-dir>/stdcells.genlib".
ABC: + strash 
ABC: + ifraig 
ABC: + scorr 
ABC: Warning: The network is combinational (run "fraig" or "fraig_sweep").
ABC: + dc2 
ABC: + dretime 
ABC: + retime 
ABC: + strash 
ABC: + &get -n 
ABC: + &dch -f 
ABC: + &nf 
ABC: + &put 
ABC: + write_blif <abc-temp-dir>/output.blif 

4.5.2. Re-integrating ABC results.
ABC RESULTS:               AND cells:       29
ABC RESULTS:               NOT cells:       20
ABC RESULTS:                OR cells:       32
ABC RESULTS:        internal signals:       42
ABC RESULTS:           input signals:       16
ABC RESULTS:          output signals:        1
Removing temp directory.

4.6. Extracting gate netlist of module `$paramod\division\M=8\K=8' to `<abc-temp-dir>/input.blif'..
Extracted 454 gates and 470 wires to a netlist network with 16 inputs and 12 outputs.

4.6.1. Executing ABC.
Running ABC command: berkeley-abc -s -f <abc-temp-dir>/abc.script 2>&1
ABC: ABC command line: "source <abc-temp-dir>/abc.script".
ABC: 
ABC: + read_blif <abc-temp-dir>/input.blif 
ABC: + read_library <abc-temp-dir>/stdcells.genlib 
ABC: Entered genlib library with 7 gates from file "<abc-temp-dir>/stdcells.genlib".
ABC: + strash 
ABC: + ifraig 
ABC: + scorr 
ABC: Warning: The network is combinational (run "fraig" or "fraig_sweep").
ABC: + dc2 
ABC: + dretime 
ABC: + retime 
ABC: + strash 
ABC: + &get -n 
ABC: + &dch -f 
ABC: + &nf 
ABC: + &put 
ABC: + write_blif <abc-temp-dir>/output.blif 

4.6.2. Re-integrating ABC results.
ABC RESULTS:               AND cells:      224
ABC RESULTS:               NOT cells:       66
ABC RESULTS:                OR cells:      203
ABC RESULTS:               XOR cells:       78
ABC RESULTS:        internal signals:      442
ABC RESULTS:           input signals:       16
ABC RESULTS:          output signals:       12
Removing temp directory.

4.7. Extracting gate netlist of module `$paramod\division_1\M=8\K=8' to `<abc-temp-dir>/input.blif'..
Extracted 260 gates and 276 wires to a netlist network with 16 inputs and 9 outputs.

4.7.1. Executing ABC.
Running ABC command: berkeley-abc -s -f <abc-temp-dir>/abc.script 2>&1
ABC: ABC command line: "source <abc-temp-dir>/abc.script".
ABC: 
ABC: + read_blif <abc-temp-dir>/input.blif 
ABC: + read_library <abc-temp-dir>/stdcells.genlib 
ABC: Entered genlib library with 7 gates from file "<abc-temp-dir>/stdcells.genlib".
ABC: + strash 
ABC: + ifraig 
ABC: + scorr 
ABC: Warning: The network is combinational (run "fraig" or "fraig_sweep").
ABC: + dc2 
ABC: + dretime 
ABC: + retime 
ABC: + strash 
ABC: + &get -n 
ABC: + &dch -f 
ABC: + &nf 
ABC: + &put 
ABC: + write_blif <abc-temp-dir>/output.blif 

4.7.2. Re-integrating ABC results.
ABC RESULTS:               AND cells:       79
ABC RESULTS:               NOT cells:       44
ABC RESULTS:                OR cells:       90
ABC RESULTS:               XOR cells:       27
ABC RESULTS:        internal signals:      251
ABC RESULTS:           input signals:       16
ABC RESULTS:          output signals:        9
Removing temp directory.

4.8. Extracting gate netlist of module `$paramod\right_shift_1\M=8\K=8' to `<abc-temp-dir>/input.blif'..
Extracted 47 gates and 63 wires to a netlist network with 16 inputs and 9 outputs.

4.8.1. Executing ABC.
Running ABC command: berkeley-abc -s -f <abc-temp-dir>/abc.script 2>&1
ABC: ABC command line: "source <abc-temp-dir>/abc.script".
ABC: 
ABC: + read_blif <abc-temp-dir>/input.blif 
ABC: + read_library <abc-temp-dir>/stdcells.genlib 
ABC: Entered genlib library with 7 gates from file "<abc-temp-dir>/stdcells.genlib".
ABC: + strash 
ABC: + ifraig 
ABC: + scorr 
ABC: Warning: The network is combinational (run "fraig" or "fraig_sweep").
ABC: + dc2 
ABC: + dretime 
ABC: + retime 
ABC: + strash 
ABC: + &get -n 
ABC: + &dch -f 
ABC: + &nf 
ABC: + &put 
ABC: + write_blif <abc-temp-dir>/output.blif 

4.8.2. Re-integrating ABC results.
ABC RESULTS:               AND cells:       47
ABC RESULTS:               NOT cells:        4
ABC RESULTS:                OR cells:       27
ABC RESULTS:        internal signals:       38
ABC RESULTS:           input signals:       16
ABC RESULTS:          output signals:        9
Removing temp directory.

4.9. Extracting gate netlist of module `$paramod\right_shift_2\M=8\K=8' to `<abc-temp-dir>/input.blif'..
Extracted 90 gates and 106 wires to a netlist network with 16 inputs and 12 outputs.

4.9.1. Executing ABC.
Running ABC command: berkeley-abc -s -f <abc-temp-dir>/abc.script 2>&1
ABC: ABC command line: "source <abc-temp-dir>/abc.script".
ABC: 
ABC: + read_blif <abc-temp-dir>/input.blif 
ABC: + read_library <abc-temp-dir>/stdcells.genlib 
ABC: Entered genlib library with 7 gates from file "<abc-temp-dir>/stdcells.genlib".
ABC: + strash 
ABC: + ifraig 
ABC: + scorr 
ABC: Warning: The network is combinational (run "fraig" or "fraig_sweep").
ABC: + dc2 
ABC: + dretime 
ABC: + retime 
ABC: + strash 
ABC: + &get -n 
ABC: + &dch -f 
ABC: + &nf 
ABC: + &put 
ABC: + write_blif <abc-temp-dir>/output.blif 

4.9.2. Re-integrating ABC results.
ABC RESULTS:               AND cells:       39
ABC RESULTS:               BUF cells:        1
ABC RESULTS:               NOT cells:       18
ABC RESULTS:                OR cells:       45
ABC RESULTS:              ZERO cells:        6
ABC RESULTS:        internal signals:       78
ABC RESULTS:           input signals:       16
ABC RESULTS:          output signals:       12
Removing temp directory.

4.10. Extracting gate netlist of module `$paramod\sub_and_mul\M=8\K=8' to `<abc-temp-dir>/input.blif'..
Extracted 113 gates and 128 wires to a netlist network with 15 inputs and 8 outputs.

4.10.1. Executing ABC.
Running ABC command: berkeley-abc -s -f <abc-temp-dir>/abc.script 2>&1
ABC: ABC command line: "source <abc-temp-dir>/abc.script".
ABC: 
ABC: + read_blif <abc-temp-dir>/input.blif 
ABC: + read_library <abc-temp-dir>/stdcells.genlib 
ABC: Entered genlib library with 7 gates from file "<abc-temp-dir>/stdcells.genlib".
ABC: + strash 
ABC: + ifraig 
ABC: + scorr 
ABC: Warning: The network is combinational (run "fraig" or "fraig_sweep").
ABC: + dc2 
ABC: + dretime 
ABC: + retime 
ABC: + strash 
ABC: + &get -n 
ABC: + &dch -f 
ABC: + &nf 
ABC: + &put 
ABC: + write_blif <abc-temp-dir>/output.blif 

4.10.2. Re-integrating ABC results.
ABC RESULTS:               AND cells:       22
ABC RESULTS:               NOT cells:       18
ABC RESULTS:                OR cells:       18
ABC RESULTS:               XOR cells:       12
ABC RESULTS:        internal signals:      105
ABC RESULTS:           input signals:       15
ABC RESULTS:          output signals:        8
Removing temp directory.

4.11. Extracting gate netlist of module `$paramod\u2_to_zm\M=8\K=8' to `<abc-temp-dir>/input.blif'..
Extracted 34 gates and 42 wires to a netlist network with 8 inputs and 9 outputs.

4.11.1. Executing ABC.
Running ABC command: berkeley-abc -s -f <abc-temp-dir>/abc.script 2>&1
ABC: ABC command line: "source <abc-temp-dir>/abc.script".
ABC: 
ABC: + read_blif <abc-temp-dir>/input.blif 
ABC: + read_library <abc-temp-dir>/stdcells.genlib 
ABC: Entered genlib library with 7 gates from file "<abc-temp-dir>/stdcells.genlib".
ABC: + strash 
ABC: + ifraig 
ABC: + scorr 
ABC: Warning: The network is combinational (run "fraig" or "fraig_sweep").
ABC: + dc2 
ABC: + dretime 
ABC: + retime 
ABC: + strash 
ABC: + &get -n 
ABC: + &dch -f 
ABC: + &nf 
ABC: + &put 
ABC: + write_blif <abc-temp-dir>/output.blif 

4.11.2. Re-integrating ABC results.
ABC RESULTS:               AND cells:       10
ABC RESULTS:               BUF cells:        2
ABC RESULTS:               NOT cells:        4
ABC RESULTS:                OR cells:        6
ABC RESULTS:               XOR cells:        5
ABC RESULTS:        internal signals:       25
ABC RESULTS:           input signals:        8
ABC RESULTS:          output signals:        9
Removing temp directory.

4.12. Extracting gate netlist of module `$paramod\zm_to_u2\M=8\K=8' to `<abc-temp-dir>/input.blif'..
Extracted 22 gates and 30 wires to a netlist network with 8 inputs and 7 outputs.

4.12.1. Executing ABC.
Running ABC command: berkeley-abc -s -f <abc-temp-dir>/abc.script 2>&1
ABC: ABC command line: "source <abc-temp-dir>/abc.script".
ABC: 
ABC: + read_blif <abc-temp-dir>/input.blif 
ABC: + read_library <abc-temp-dir>/stdcells.genlib 
ABC: Entered genlib library with 7 gates from file "<abc-temp-dir>/stdcells.genlib".
ABC: + strash 
ABC: + ifraig 
ABC: + scorr 
ABC: Warning: The network is combinational (run "fraig" or "fraig_sweep").
ABC: + dc2 
ABC: + dretime 
ABC: + retime 
ABC: + strash 
ABC: + &get -n 
ABC: + &dch -f 
ABC: + &nf 
ABC: + &put 
ABC: + write_blif <abc-temp-dir>/output.blif 

4.12.2. Re-integrating ABC results.
ABC RESULTS:               AND cells:        8
ABC RESULTS:               BUF cells:        1
ABC RESULTS:               NOT cells:        2
ABC RESULTS:                OR cells:        6
ABC RESULTS:               XOR cells:        5
ABC RESULTS:        internal signals:       15
ABC RESULTS:           input signals:        8
ABC RESULTS:          output signals:        7
Removing temp directory.

4.13. Extracting gate netlist of module `\synth_new_alu' to `<abc-temp-dir>/input.blif'..
Extracted 248 gates and 397 wires to a netlist network with 149 inputs and 13 outputs.

4.13.1. Executing ABC.
Running ABC command: berkeley-abc -s -f <abc-temp-dir>/abc.script 2>&1
ABC: ABC command line: "source <abc-temp-dir>/abc.script".
ABC: 
ABC: + read_blif <abc-temp-dir>/input.blif 
ABC: + read_library <abc-temp-dir>/stdcells.genlib 
ABC: Entered genlib library with 7 gates from file "<abc-temp-dir>/stdcells.genlib".
ABC: + strash 
ABC: + ifraig 
ABC: + scorr 
ABC: Warning: The network is combinational (run "fraig" or "fraig_sweep").
ABC: + dc2 
ABC: + dretime 
ABC: + retime 
ABC: + strash 
ABC: + &get -n 
ABC: + &dch -f 
ABC: + &nf 
ABC: + &put 
ABC: + write_blif <abc-temp-dir>/output.blif 

4.13.2. Re-integrating ABC results.
ABC RESULTS:               AND cells:      214
ABC RESULTS:               NOT cells:        7
ABC RESULTS:                OR cells:      142
ABC RESULTS:               XOR cells:        7
ABC RESULTS:        internal signals:      235
ABC RESULTS:           input signals:      149
ABC RESULTS:          output signals:       13
Removing temp directory.

5. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module $paramod\absolute\M=8\K=8..
Finding unused cells or wires in module $paramod\add_bit\M=8\K=8..
Finding unused cells or wires in module $paramod\addition_1\M=8\K=8..
Finding unused cells or wires in module $paramod\comparison_1\M=8\K=8..
Finding unused cells or wires in module $paramod\comparison_2\M=8\K=8..
Finding unused cells or wires in module $paramod\division\M=8\K=8..
Finding unused cells or wires in module $paramod\division_1\M=8\K=8..
Finding unused cells or wires in module $paramod\right_shift_1\M=8\K=8..
Finding unused cells or wires in module $paramod\right_shift_2\M=8\K=8..
Finding unused cells or wires in module $paramod\sub_and_mul\M=8\K=8..
Finding unused cells or wires in module $paramod\u2_to_zm\M=8\K=8..
Finding unused cells or wires in module $paramod\zm_to_u2\M=8\K=8..
Finding unused cells or wires in module \synth_new_alu..
Removed 0 unused cells and 1969 unused wires.
<suppressed ~13 debug messages>

6. Executing Verilog backend.
Dumping module `$paramod\absolute\M=8\K=8'.
Dumping module `$paramod\add_bit\M=8\K=8'.
Dumping module `$paramod\addition_1\M=8\K=8'.
Dumping module `$paramod\comparison_1\M=8\K=8'.
Dumping module `$paramod\comparison_2\M=8\K=8'.
Dumping module `$paramod\division\M=8\K=8'.
Dumping module `$paramod\division_1\M=8\K=8'.
Dumping module `$paramod\right_shift_1\M=8\K=8'.
Dumping module `$paramod\right_shift_2\M=8\K=8'.
Dumping module `$paramod\sub_and_mul\M=8\K=8'.
Dumping module `$paramod\u2_to_zm\M=8\K=8'.
Dumping module `$paramod\zm_to_u2\M=8\K=8'.
Dumping module `\synth_new_alu'.

7. Printing statistics.
